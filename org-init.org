#+TITLE: Literate Emacs configuration
#+AUTHOR: Timm Lichte
#+FILETAGS: emacs
#+STARTUP: indent
#+STARTUP: hideblocks content

* Good examples

- http://ivanmalison.github.io/dotfiles/
- https://github.com/novoid/dot-emacs/blob/master/config.org

* General appearence

** Toolbar

Don't show toolbar:
#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
#+END_SRC

** Start-up

*** dashboard

#+BEGIN_SRC emacs-lisp
(use-package dashboard
	:ensure t
	:diminish dashboard-mode
	:config
	(setq
	 dashboard-banner-logo-title (emacs-version)
	 dashboard-startup-banner 'logo
	 dashboard-items '((recents  . 10)
										 (bookmarks . 10)
										 (projects . 5)
										 )
	 )

	(add-to-list 'dashboard-item-generators  '(custom-settings . dashboard-insert-custom-settings))
	(add-to-list 'dashboard-items '(custom-settings) t)

	(define-key dashboard-mode-map (kbd "<up>") (lambda () (interactive)(widget-forward -1)))
	(define-key dashboard-mode-map (kbd "<down>") (lambda () (interactive)(widget-forward 1)))

	(dashboard-setup-startup-hook)
	)
#+END_SRC

Custom settings (https://www.gnu.org/software/emacs/manual/html_mono/widget.html):

#+BEGIN_SRC emacs-lisp
(defun dashboard-insert-custom-settings (&rest ignore)
	(interactive)
  (widget-insert "Custom settings:\n\t\t")
	(widget-create 'checkbox
								 :notify (lambda (&rest ignore)
													 (if (bound-and-true-p cua-mode)
															 (progn (cua-mode nil)
																			(customize-save-variable 'cua-mode nil))
														 (cua-mode t)
														 (customize-save-variable 'cua-mode t)
														 ))
								 (bound-and-true-p cua-mode))
	(widget-insert " Use CUA-mode?"))
#+END_SRC

** Signals

No beep:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

** Syntax highlighting

Brackets:
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Apply syntax highlighting to all buffers:
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

*** highlight-symbol

#+BEGIN_SRC emacs-lisp
(use-package highlight-symbol
  :ensure t
  :config
  (setq highlight-symbol-idle-delay 0.2)
  (add-hook 'highlight-symbol-mode-hook
            (function
             (lambda () (highlight-symbol-nav-mode +1)))))
#+END_SRC

** Lines

Highlight line of cursor:
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode t)
#+END_SRC

Soft-wrap lines:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
#+END_SRC

Line numbers:
#+BEGIN_SRC emacs-lisp
;; (global-linum-mode t)
;; (setq linum-format " %3d ")
#+END_SRC

** Cursor

Cursor blinking:
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 1)										; blink
(setq blink-cursor-blinks 0)						; blink forever
#+END_SRC

** Theme

Theme:
#+BEGIN_SRC emacs-lisp
(setq themes-dir
      (expand-file-name "themes" user-emacs-directory))
(add-to-list 'custom-theme-load-path themes-dir)
(load-theme 'monokai t)
#+END_SRC

** Mode line and window labels

Mode line:
#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
	:ensure t
	:init
	;; (setq sml/theme 'dark)
	(setq sml/no-confirm-load-theme t)
	:config
	(sml/setup)
	)
#+END_SRC

Show file path in window title:
#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '(buffer-file-name "%b - %f" ; File buffer
        (dired-directory dired-directory ; Dired buffer
         (revert-buffer-function "%b" ; Buffer Menu
																 ("%b - Dir: " default-directory))))) ; Plain buffer
#+END_SRC

Show date and time:
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(display-time-mode +1)
#+END_SRC

Fringe style:
#+BEGIN_SRC emacs-lisp
;; (set-face-attribute 'fringe nil :background "#3F3F3F" :foreground "#3F3F3F")
#+END_SRC

** Distraction-free mode

*** writeroom-mode

#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
	:ensure t
	:bind
	(:map writeroom-mode-map
				("C-M-<" . writeroom-decrease-width)
				("C-M->" . writeroom-increase-width)
				("C-M-=" . writeroom-adjust-width)
				("C-<f10>" . writeroom-toggle-mode-line)
				)
	)
(global-set-key (kbd "<f10>") 'writeroom-mode)
#+END_SRC

** Font 

Toggle proportional mode when appropriate.
Inspired by https://ogbe.net/blog/toggle-serif.html
#+BEGIN_SRC emacs-lisp
(defvar font-preserve-default-list nil
  "A list holding the faces that preserve the default family and
  height when TOGGLE-SERIF is used.")
(setq font-preserve-default-list
      '(;; LaTeX markup
        font-latex-math-face
        font-latex-sedate-face
        font-latex-warning-face
        ;; org markup
        org-latex-and-related
        org-meta-line
        org-verbatim
        org-block-begin-line
        ;; syntax highlighting using font-lock
        font-lock-builtin-face
        font-lock-comment-delimiter-face
        font-lock-comment-face
        font-lock-constant-face
        font-lock-doc-face
        font-lock-function-name-face
        font-lock-keyword-face
        font-lock-negation-char-face
        font-lock-preprocessor-face
        font-lock-regexp-grouping-backslash
        font-lock-regexp-grouping-construct
        font-lock-string-face
        font-lock-type-face
        font-lock-variable-name-face
        font-lock-warning-face))
(defun toggle-proportional ()
  "Change the default face of the current buffer to use a proportional family."
  (interactive)
  (when (display-graphic-p)  ;; this is only for graphical emacs
    ;; the serif font familiy and height, save the default attributes
    (let ((proportional-fam "Segoe UI")
          (proportional-height 125)
          (default-fam (face-attribute 'default :family))
          (default-height (face-attribute 'default :height)))
      (if (not (bound-and-true-p default-cookie))
          (progn (make-local-variable 'default-cookie)
                 (make-local-variable 'preserve-default-cookies-list)
                 (setq preserve-default-cookies-list nil)
                 ;; remap default face to serif
                 (setq default-cookie
                       (face-remap-add-relative
                        'default :family proportional-fam :height proportional-height))
                 ;; keep previously defined monospace fonts the same
                 (dolist (face font-preserve-default-list)
                   (add-to-list 'preserve-default-cookies-list
                                (face-remap-add-relative
                                 face :family default-fam :height default-height)))
                 (message "Turned on proportional font."))
        ;; undo changes
        (progn (face-remap-remove-relative default-cookie)
               (dolist (cookie preserve-default-cookies-list)
                 (face-remap-remove-relative cookie))
               (setq default-cookie nil)
               (setq preserve-default-cookies-list nil)
               (message "Restored default fonts."))))))
#+END_SRC

** Overlays

#+BEGIN_SRC emacs-lisp
(use-package ov
  :ensure t)
#+END_SRC

* Minibuffer

Shorten yes/no answers to y/n:
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** ido, ivy, imenu

*** ido

#+BEGIN_SRC emacs-lisp
;; ;; ido improves buffer switching experience
;; (ido-mode 1)
;; (ido-everywhere 1)
;; ;; add vertical mode to ido
;; (use-package ido-vertical-mode	
;; 	:ensure t
;; 	:config (ido-vertical-mode 1)	)
;; ;; add grid mode
;; (use-package ido-grid-mode
;; 	:ensure t
;; 	:config (ido-grid-mode 1))												
;; ;; add flx to ido 
;; (use-package flx-ido
;; 	:ensure t
;; 	:config 
;; 	(flx-ido-mode 1)
;; 	;; disable ido faces to see flx highlights.
;; 	(setq ido-enable-flex-matching t)
;; 	(setq ido-use-faces nil))
#+END_SRC

*** Recent files

#+BEGIN_SRC emacs-lisp
;; ;; recent files
;; (require 'recentf)
;; (recentf-mode 1)
;; ; 50 files ought to be enough.
;; (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
;; (setq recentf-max-saved-items 50)
;; (defun ido-recentf-open ()
;; 	"Use `ido-completing-read' to \\[find-file] a recent file"
;; 	(interactive)
;; 	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
;; 			(message "Opening file...")
;; 		(message "Aborting")))

#+END_SRC

*** ivy, counsel, swiper

#+BEGIN_SRC emacs-lisp
;; ;; counsel adds fuzzy search to command completion 
;; (use-package counsel
;; 	:ensure t
;; 	:config
;; 	(setq ivy-display-style 'fancy)
;; 	(setq ivy-re-builders-alist ; use flx
;; 				'((t . ivy--regex-fuzzy)))
;; 	(setq ivy-initial-inputs-alist nil) ; omit ^
;; 	(setq ivy-wrap t) ;; cycle through results
;; 	:bind
;; 	("M-x" . counsel-M-x)
;; 	("C-ß" . ivy-imenu-anywhere) ; ivy + imenu
;; 	)
;; ;; swiper
;; (use-package swiper
;; 	:ensure t
;; 	:config
;; 	;; use swiper for buffer search
;; 	(add-hook 'prog-mode-hook
;; 						(lambda ()
;; 							(local-set-key (kbd "C-s") 'swiper)))
;; 	;; (global-set-key (kbd "C-s") 'swiper) ; not good in text-mode
;; 	)
#+END_SRC

*** imenu

#+BEGIN_SRC emacs-lisp
(use-package imenu-anywhere
	:ensure t)
(use-package imenu-list
	:ensure t
	:bind
	("C-?" . imenu-list)
	:init
	(setq imenu-list-focus-after-activation t)
	;; (setq imenu-list-auto-resize t)
	(setq imenu-list-position (quote left))
	(setq imenu-list-size 30)
	:config
	(add-hook 'text-mode-hook 'imenu-list-minor-mode)
	(add-hook 'prog-mode-hook 'imenu-list-minor-mode)
	)
(add-hook 'imenu-list-minor-mode-hook (lambda () (toggle-truncate-lines))) ; FIXME
(setq org-imenu-depth 4)
#+END_SRC

*** smex

Smex helps to remember often used commands; used by ido and counsel
#+BEGIN_SRC emacs-lisp
;; (use-package smex
;; 	:ensure t)
#+END_SRC

** TODO helm

- [ ] does not complete org-set-tags

#+BEGIN_SRC emacs-lisp
(use-package helm
  :diminish helm-mode
  :init
  (progn
    (require 'helm-config)
    (setq helm-candidate-number-limit 100)
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01		; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t		 ; do not display invisible candidates
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t
					helm-mode-fuzzy-match t 			; global fuzzy match
					helm-buffers-fuzzy-matching t
					helm-recentf-fuzzy-match t
					helm-M-x-fuzzy-match t
          helm-follow-mode-persistent t	; follow candidate in buffer (with C-up/C-down)
					helm-imenu-fuzzy-match t
					helm-completion-in-region-fuzzy-match t
					helm-apropos-fuzzy-match t
					helm-autoresize-mode 1 				; re-size the completion window based on number of candidates
					helm-adaptive-mode t					; show commonly used commands first
					)
		(setq bibtex-completion-bibliography user-bibliography-file
					bibtex-completion-library-path user-bibliography-pdf-dir ; directory of PDFs
					;; bibtex-completion-notes-path "~/bibliography/helm-bibtex-notes"
					)
		
		;; helm-mini
		(setq helm-mini-default-sources
					'(helm-source-buffers-list
						helm-source-bookmarks
						helm-source-recentf
						helm-source-buffer-not-found)) 

    (helm-mode)

		;; ;; http://emacs.stackexchange.com/a/7896/12336
		;; ;; <return> opens directory in helm-find-files, not dired
		;; (defun fu/helm-find-files-navigate-forward (orig-fun &rest args)
		;; 	(if (file-directory-p (helm-get-selection))
		;; 			(apply orig-fun args)
		;; 		(helm-maybe-exit-minibuffer)))
		;; (advice-add 'helm-execute-persistent-action :around #'fu/helm-find-files-navigate-forward)
		;; (define-key helm-find-files-map (kbd "<return>") 'helm-execute-persistent-action)
		
    ;; http://emacs.stackexchange.com/a/7896/12336
		;; <backspace> before backslash lets helm-find-files  move one directory up
		(defun fu/helm-find-files-navigate-back (orig-fun &rest args)
			(if (= (length helm-pattern) (length (helm-find-files-initial-input)))
					(helm-find-files-up-one-level 1)
				(apply orig-fun args)))
		(advice-add 'helm-ff-delete-char-backward :around #'fu/helm-find-files-navigate-back)

		;; https://redd.it/3f55nm
		;; remove . and .. from helm-find-files
		(advice-add 'helm-ff-filter-candidate-one-by-one
								:around (lambda (fcn file)
													(unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
														(funcall fcn file))))

		)
  :bind (("M-y" . helm-mini)
				 ("C-x C-r" . helm-recentf)
         ("C-h a" . helm-apropos)
         ("C-x C-b" . helm-buffers-list)
         ("C-x b" . helm-buffers-list)
				 ("C-x C-f" . helm-find-files)
         ("C-x C-y" . helm-show-kill-ring)
         ("C-x y" . helm-show-kill-ring)
         ("C-x t" . helm-etags-select)
				 ("C-x C-t" . helm-etags-select)
         ("C-x SPC" . helm-all-mark-rings)
         ("C-x C-SPC" . helm-all-mark-rings)				 
         ("M-x" . helm-M-x)
         ("C-s" . helm-occur)
         ;; ("C-x c s" . helm-swoop)
         ("C-x c y" . helm-yas-complete)
         ("C-x c Y" . helm-yas-create-snippet-on-region)
         ("C-x c SPC" . helm-all-mark-rings)
				 ("C-ß" . helm-imenu)
				 ("C-S-?" . helm-imenu-anywhere)
				 )
)
(ido-mode -1)														; turn off ido mode, just in case

;; helm-flx: improves fuzzy matching
(use-package helm-flx
	:ensure t
	:after helm
	:config
	(helm-flx-mode +1))
;; helm-fuzzier: improves fuzzy matching even more by taking more candidates into account
(use-package helm-fuzzier
	:ensure t
	:after helm
	:config
	(helm-fuzzier-mode +1))

;; list active key bindings 
(use-package helm-descbinds
	:ensure t
  :bind ("C-h b" . helm-descbinds))
#+end_src

*** helm-swoop

#+begin_src emacs-lisp
(use-package helm-swoop
	:ensure t
	:config
	;; Move up and down like isearch
	(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
	(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
	(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

	;; From helm-swoop to helm-multi-swoop-all
	(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

	;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
	(define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)
	
	;; If nil, you can slightly boost invoke speed in exchange for text color
	(setq helm-swoop-speed-or-color t)
	
	;; Optional face for line numbers
	;; Face name is `helm-swoop-line-number-face`
	(setq helm-swoop-use-line-number-face t)

	;; If you prefer fuzzy matching (seems to be already activated)
	;; (setq helm-swoop-use-fuzzy-match t)

	;; Do not call helm-swoop with symbol or word at point
	(setq helm-swoop-pre-input-function
				(lambda () nil))

  :bind ("C-c /" . helm-swoop))
#+END_SRC

*** helm-dash

=helm-dash= depends on =sqlite3= which you probably have to install manually:
http://sqlite.org/download.html

#+BEGIN_SRC emacs-lisp
	(use-package helm-dash
		:ensure t
		:init
		(setq helm-dash-common-docsets			; active in all buffers
					'())
		(setq helm-dash-browser-func 'eww)		; use internal web browser
		(setq helm-dash-docsets-path (expand-file-name (concat wemacs-dir "/docsets"))) ; FIXME: under windows, helm-dash does not install docsets here but in ~/AppData/... Because of missing tar command?
		(add-hook 'latex-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
		(add-hook 'TeX-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("LaTeX"))))
		(add-hook 'emacs-lisp-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Emacs Lisp"))))
		(add-hook 'org-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Org_Mode"))))
		(add-hook 'plantuml-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("PlantUML"))))
		(add-hook 'sh-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Bash"))))
		(add-hook 'perl-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Perl"))))
		(add-hook 'python-mode-hook (lambda () (interactive)(setq-local helm-dash-docsets '("Python 3" "SciPy" "NumPy"))))
		:bind
		(("C-h d" . helm-dash))
		)
#+END_SRC

*** TODO COMMENT helm-gtags

- [ ]  [[*GLOBAL][GLOBAL]] has to be properly installed first. 

#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :ensure t
  :config
  (setq helm-gtags-path-style 'absolute)
  (progn
    ;; keys
    (define-key helm-gtags-mode-map (kbd "C-c f") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-t") 'helm-gtags-find-tag)
    (define-key helm-gtags-mode-map (kbd "M-r") 'helm-gtags-find-rtag)
    (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-find-symbol)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
		(define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack))
	(add-hook 'prog-mode-hook 'helm-gtags-mode))
#+END_SRC

*** COMMENT helm-tramp

Does not work under windows so far. Therefore I commented this out:

#+BEGIN_SRC emacs-lisp
(use-package helm-tramp
	:ensure t)
#+END_SRC

*** dictcc

#+BEGIN_SRC emacs-lisp
(use-package dictcc
	:ensure t
	:bind
	(("C-0" . dictcc))
)
#+END_SRC

Call dictcc with word under cursor or marked region:
#+BEGIN_SRC emacs-lisp
(defun tl/dictcc-at-point ()
  (interactive)
	(if (use-region-p)
			(dictcc (concat "\"" (filter-buffer-substring (region-beginning) (region-end)) "\""))
		(if (word-at-point)
				(dictcc (word-at-point))
      (call-interactively 'dictcc))
		))
(global-set-key (kbd "C-0") 'tl/dictcc-at-point)
#+END_SRC

*** helm-org-rifle 

Quick, comprehensive search on org-mode files.

#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
	:ensure t
  :config
	(define-key helm-org-rifle-map (kbd "<left>") 'backward-char) ; instead of helm-previous-source
	(define-key helm-org-rifle-map (kbd "<right>") 'forward-char) ; instead of helm-next-source
	(define-key helm-org-rifle-map (kbd "C-n") 'helm-next-source)
	(define-key helm-org-rifle-map (kbd "C-p") 'helm-previous-source)
)
#+END_SRC

*** Key bindings

#+BEGIN_SRC emacs-lisp
(define-key helm-map (kbd "C-n") 'helm-next-source)
(define-key helm-map (kbd "C-p") 'helm-previous-source)
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; complete with <tab> (default is <ret>)
(define-key helm-map (kbd "C-z") 'helm-select-action) ; show actions (default is <tab>)
(define-key helm-map (kbd "<left>") 'backward-char) ; instead of C-f
(define-key helm-map (kbd "<right>") 'forward-char) ; instead of C-b
(define-key helm-map (kbd "M-<left>") 'previous-history-element)
(define-key helm-map (kbd "M-<right>") 'next-history-element)
#+END_SRC

** Keys

#+BEGIN_SRC emacs-lisp
(use-package which-key
	:ensure t
	:config
	(which-key-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; M-x in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-x") 'abort-recursive-edit)))

;; M-y in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "M-y") 'abort-recursive-edit)))

;; C-ß in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-ß") 'abort-recursive-edit)))

;; C-s in minibuffer quits the minibuffer
(add-hook 'minibuffer-setup-hook
					(lambda ()
						(local-set-key (kbd "C-s") 'abort-recursive-edit)))

;; (global-set-key (kbd "C-x C-b") 'switch-to-buffer) ; instead of 'list-buffers (see helm)
;; (global-set-key (kbd "C-x b") 'ibuffer)
(global-set-key (kbd "C-x C-k") 'kill-buffer)  
#+END_SRC

* Major modes

** web-mode

#+BEGIN_SRC emacs-lisp
(use-package web-mode										; for improved html support
	:ensure t
	:mode
	("\\.phtml\\'" . web-mode)
	("\\.tpl\\.php\\'" . web-mode)
	("\\.[agj]sp\\'" . web-mode)
	("\\.as[cp]x\\'" . web-mode)
	("\\.erb\\'" . web-mode)
	("\\.mustache\\'" . web-mode)
	("\\.djhtml\\'" . web-mode)
	("\\.html?\\'" . web-mode)
	("\\.xml\\'" . web-mode)
	("\\.css\\'" . web-mode)
	:config
	;; highlight enclosing tags of the element under cursor
  (setq web-mode-enable-current-element-highlight t)
)
#+END_SRC

** Graphviz/dot

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t
	:mode "\\.dot\\'")
#+END_SRC

** TODO Gnuplot

- [ ] compiling Gnuplot crashes Emacs

#+BEGIN_SRC emacs-lisp
(use-package gnuplot
	:ensure t)
#+END_SRC

** Python

*** elpy

Prerequisites as for Python:
#+BEGIN_SRC bash
	sudo pip install jedi flake8 importmagic autopep8 # Elpy's recommendation
	sudo pip install pylint virtualenv epc # Zamansky's recommendation
#+END_SRC

#+BEGIN_SRC emacs-lisp
	(use-package elpy
		:ensure t
		:defer 2
		:config
		(progn
			;; Use Flycheck instead of Flymake
			(when (require 'flycheck nil t)
				(remove-hook 'elpy-modules 'elpy-module-flymake)
				(remove-hook 'elpy-modules 'elpy-module-yasnippet)
				(remove-hook 'elpy-mode-hook 'elpy-module-highlight-indentation)
				(add-hook 'elpy-mode-hook 'flycheck-mode))
			(elpy-enable)
			(define-key python-mode-map (kbd "C-h f") 'python-eldoc-at-point)
			;; highlight-indentation is ugly
			(add-hook 'elpy-mode-hook '(lambda () (highlight-indentation-mode -1)))
			;; jedi is great
			(setq elpy-rpc-backend "jedi")))
#+END_SRC

*** company-jedi

#+BEGIN_SRC emacs-lisp
;; Use Company for auto-completion interface.
(defun my/python-mode-hook ()
  (add-to-list 'company-backends 'company-jedi))

(use-package company-jedi
  :ensure t
  :init
  (add-hook 'python-mode-hook 'my/python-mode-hook))
#+END_SRC

** PlantUML

Depends on plantuml.jar and Gaphviz (http://www.graphviz.org).

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :ensure t
  :mode ("\\.plu\\'" "\\.puml\\'") 
  :init
	(setq org-plantuml-jar-path
				(expand-file-name "plantuml.jar" wemacs-dir))
	(setq plantuml-jar-path
				(expand-file-name "plantuml.jar" wemacs-dir)))
#+END_SRC

** dired

*** General settings

Tips:  http://ergoemacs.org/emacs/emacs_dired_tips.html

Do not open new buffer when opening a file/directory: 
#+BEGIN_SRC emacs-lisp
;; (define-key dired-mode-map (kbd "<return>") 'dired-find-alternate-file) ; was dired-advertised-find-file
(define-key dired-mode-map (kbd "<backspace>") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory
(define-key dired-mode-map (kbd "<left>") (lambda () (interactive) (find-alternate-file "..")))  ; was 
#+END_SRC

View file and return to dired with q:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<tab>") 'dired-view-file)
(define-key dired-mode-map (kbd "<right>") 'dired-view-file)
(add-hook 'view-mode-hook
  (lambda ()
    (define-key view-mode-map (kbd "<left>") 'View-quit)
		(define-key view-mode-map (kbd "<right>") 'View-exit-and-edit)
    ))
#+END_SRC

Copy/move into other dired buffer:
#+BEGIN_SRC emacs-lisp
(setq dired-dwim-target t)
#+END_SRC

Show details of files and directories:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook
          (lambda () (dired-hide-details-mode -1)))
#+END_SRC

Don't break lines:
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-initial-position-hook '(lambda () (setq truncate-lines t)))
;; (add-hook 'dired-mode-hook (lambda () (setq truncate-lines t)))
#+END_SRC

Order directories first (only windows?):
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-dirs-first t)
#+END_SRC

Other settings: http://oremacs.com/2015/01/13/dired-options/

#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-laGh1v")
#+END_SRC

Chose Windows drives:
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
	(define-key dired-mode-map (kbd "\\") 'diredp-w32-drives))
#+END_SRC

Move to trash can (recycle bin under windows) when deleting:
#+BEGIN_SRC emacs-lisp
(setq delete-by-moving-to-trash t)
#+END_SRC

*** Mark/Unmark 

Use shift-up and shift-down in the usual way.
See http://emacs.stackexchange.com/a/30890/12336

#+BEGIN_SRC emacs-lisp
(defun my-dired-toggle (arg)
  (save-restriction
    (narrow-to-region (point-at-bol) (point-at-eol))
    (dired-toggle-marks))
	(dired-previous-line arg))

(defun my-dired-mark-up ()
  (interactive)
  (my-dired-toggle 1))

(defun my-dired-mark-down ()
  (interactive)
  (my-dired-toggle -1))

(define-key dired-mode-map (kbd "<S-up>") 'my-dired-mark-up)
(define-key dired-mode-map (kbd "<S-down>") 'my-dired-mark-down)
#+END_SRC

*** TODO COMMENT Open binary files in external programm

#+BEGIN_SRC
advice(dired-find-file :before)
if (dired-get-file-for-visit ~= /^.*\.(pdf|wav|mp3|flac|...)/ ) {
  xah-open-in-external-app(dired-get-file-for-visit)
  return t
} 
#+END_SRC

*** Open in external programm

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-external-app ()
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference.
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2016-10-15"
  (interactive)
  (let* (
         (-file-list
          (if (string-equal major-mode "dired-mode")
              (dired-get-marked-files)
            (list (buffer-file-name))))
         (-do-it-p (if (<= (length -file-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))
    (when -do-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (-fpath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" -fpath t t))) -file-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (-fpath)
           (shell-command
            (concat "open " (shell-quote-argument -fpath))))  -file-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (-fpath) (let ((process-connection-type nil))
                            (start-process "" nil "xdg-open" -fpath))) -file-list))))))

(define-key dired-mode-map (kbd "C-<return>") 'xah-open-in-external-app)
#+END_SRC

*** Open in external file browser

#+BEGIN_SRC emacs-lisp
(defun xah-open-in-desktop ()
  "Show current file in desktop (OS's file manager).
URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2015-11-30"
  (interactive)
  (cond
   ((string-equal system-type "windows-nt")
    (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
   ((string-equal system-type "darwin") (shell-command "open ."))
   ((string-equal system-type "gnu/linux")
    (let (
          (process-connection-type nil)
          (openFileProgram (if (file-exists-p "/usr/bin/gvfs-open")
                               "/usr/bin/gvfs-open"
                             "/usr/bin/xdg-open")))
      (start-process "" nil openFileProgram "."))
    ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. For example: with nautilus
    )))
#+END_SRC

*** Special keys
**** Copy path

Sometimes its useful to copy the path of a file or directory under cursor:

#+BEGIN_SRC emacs-lisp
(defun tl/dired-copy-path-at-point ()
	(interactive)
	(dired-copy-filename-as-kill 0)
)

(define-key dired-mode-map (kbd "W") 'tl/dired-copy-path-at-point)
#+END_SRC

**** Delete 

Delete with <delete> key.

#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<delete>") 'dired-do-delete)
#+END_SRC

*** dired-imenu

#+BEGIN_SRC emacs-lisp
(use-package dired-imenu
	:ensure t
	:init
	(require 'dired-imenu)
)
#+END_SRC

*** dired-k

#+BEGIN_SRC emacs-lisp
(use-package dired-k
	:ensure t
	:bind (:map dired-mode-map ("K" . dired-k))
	:config
  (progn
		;; FIXME: Tramp prompts for the password in every new dired buffer!
		;; (add-hook 'dired-initial-position-hook 'dired-k)
		;; (add-hook 'dired-after-readin-hook #'dired-k-no-revert)
))
#+END_SRC

*** TODO COMMENT dired-quick-sort

- [ ] Grouping (=--group-directories-first=) does not work under windows.

Depends on =ls=.

#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
	:ensure t
	:init
	(require 'dired-quick-sort)
	(dired-quick-sort-setup)
	)
#+END_SRC

*** dired+

#+BEGIN_SRC emacs-lisp
(use-package dired+
  :ensure t
  :config
  (require 'dired+)
  (setq diredp-hide-details-initially-flag nil)
  (set-face-foreground 'diredp-file-name nil)
  ;; Keep dired buffers updated when the file system changes.
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil))
#+END_SRC

<mouse-1> opens file/directory in the same window:
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "<mouse-2>") 'diredp-mouse-find-file)
#+END_SRC

*** dired-hacks

Several helper packages for dired.
See documentation here: https://github.com/Fuco1/dired-hacks

**** dired-narrow

Filter dired list on the fly:

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
							("/" . dired-narrow)
							:map dired-narrow-map
              ("<tab>" . dired-narrow-enter-directory)
              ("<right>" . dired-view-file)
							("<return>" . exit-minibuffer))        
	:config
	(setq dired-narrow-exit-action 'dired-narrow-find-file)
)
#+END_SRC

**** COMMENT dired-subtree

Taken from: https://github.com/Fuco1/.emacs.d/blob/master/files/dired-defs.el

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :init
  (bind-keys :map dired-mode-map
             :prefix "C-,"
             :prefix-map dired-subtree-map
             :prefix-docstring "Dired subtree map."
    ("<C-i-key>" . dired-subtree-insert)
    ("C-/" . dired-subtree-apply-filter)
    ("C-k" . dired-subtree-remove)
    ("C-n" . dired-subtree-next-sibling)
    ("C-p" . dired-subtree-previous-sibling)
    ("C-u" . dired-subtree-up)
    ("C-d" . dired-subtree-down)
    ("C-a" . dired-subtree-beginning)
    ("C-e" . dired-subtree-end)
    ("C-c" . dired-subtree-cycle)
    ("m" . dired-subtree-mark-subtree)
    ("u" . dired-subtree-unmark-subtree)
    ("C-o C-f" . dired-subtree-only-this-file)
    ("C-o C-d" . dired-subtree-only-this-directory)))

#+END_SRC

**** TODO dired-rainbow

More customizable highlightning in dired listings.
Settings inspired by https://github.com/Fuco1/.emacs.d/blob/master/files/dired-defs.el

- [ ] Does not seem to work.

#+BEGIN_SRC emacs-lisp
(defconst my-dired-media-files-extensions '("mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma")
  "Media file extensions that should launch in VLC.
Also used for highlighting.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-rainbow
	:ensure t 
  :config
  (progn
    (dired-rainbow-define html "#4e9a06" ("htm" "html" "xhtml"))
    (dired-rainbow-define xml "#b4fa70" ("xml" "xsd" "xsl" "xslt" "wsdl"))

    (dired-rainbow-define document "#fce94f" ("doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub"))
    (dired-rainbow-define excel "#3465a4" ("xlsx"))
    (dired-rainbow-define media "#ce5c00" my-dired-media-files-extensions)
    (dired-rainbow-define image "#ff4b4b" ("jpg" "png" "jpeg" "gif"))

    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define sourcefile "#fcaf3e" ("py" "c" "cc" "h" "java" "pl" "rb" "R" "php"))

    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#ad7fa8" ("zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#e6a8df" ("deb" "rpm"))
    (dired-rainbow-define encrypted "LightBlue" ("gpg" "pgp"))

    (dired-rainbow-define-chmod executable-unix "Green" "-.*x.*")
    ))
#+END_SRC

**** dired-ranger

#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
	:ensure t
  :config
  (setq dired-ranger-copy-ring-size 1)
	(define-key dired-mode-map (kbd "C-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)	; t adds item to dired-ranger-copy-ring
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-move)))
	(define-key dired-mode-map (kbd "M-w")
		(lambda ()
			(interactive)
			(dired-ranger-copy nil)
			(define-key dired-mode-map (kbd "C-y") 'dired-ranger-paste)))
)
#+END_SRC

**** COMMENT dired-collapse

#+BEGIN_SRC emacs-lisp
(use-package dired-collapse
	:ensure t)
#+END_SRC

*** dired-efap

Rename file name at point.

#+BEGIN_SRC emacs-lisp
(use-package dired-efap
	:ensure t
	:config
	(setq dired-efap-initial-filename-selection nil)
	(define-key dired-mode-map (kbd "r") 'dired-efap)
	)
#+END_SRC

*** ediff 

Quick ediff on marked files.
Copied from https://oremacs.com/2017/03/18/dired-ediff/:
#+BEGIN_SRC emacs-lisp
(defun ora-ediff-files ()
  (interactive)
  (let ((files (dired-get-marked-files))
        (wnd (current-window-configuration)))
    (if (<= (length files) 2)
        (let ((file1 (car files))
              (file2 (if (cdr files)
                         (cadr files)
                       (read-file-name
                        "file: "
                        (dired-dwim-target-directory)))))
          (if (file-newer-than-file-p file1 file2)
              (ediff-files file2 file1)
            (ediff-files file1 file2))
          (add-hook 'ediff-after-quit-hook-internal
                    (lambda ()
                      (setq ediff-after-quit-hook-internal nil)
                      (set-window-configuration wnd))))
      (error "no more than 2 files should be marked"))))

(define-key dired-mode-map "e" 'ora-ediff-files)
#+END_SRC

*** imenu

Integrate imenu into dired.
Copied from https://fuco1.github.io/2017-05-01-Support-for-imenu-in-dired.html 

#+BEGIN_SRC emacs-lisp
(defun my-dired-imenu-prev-index-position (&optional arg)
  "Go to the header line of previous directory."
  (interactive "p")
  (unless (= (line-number-at-pos) 1)
    (call-interactively 'dired-prev-subdir)
    t))

(defun my-dired-extract-index-name ()
  "Extract name of the current item for imenu."
  (save-excursion
    (back-to-indentation)
    (buffer-substring-no-properties
     (point)
     (1- (re-search-forward ":$")))))

(defun my-dired-imenu-create-index ()
  "Create `imenu' index for dired."
  (let* ((alist (imenu-default-create-index-function))
         (uniquified (f-uniquify-alist (-map 'car alist))))
    (--remove
     (= 0 (length (car it)))
     (--map (cons (cdr (assoc (car it) uniquified)) (cdr it))
            alist))))

(defun my-dired-imenu-init ()
  "Initialize `imenu' variables in current buffer."
  (setq-local imenu-prev-index-position-function
              'my-dired-imenu-prev-index-position)
  (setq-local imenu-extract-index-name-function
              'my-dired-extract-index-name)
  (setq-local imenu-create-index-function
              'my-dired-imenu-create-index))

(add-hook 'dired-mode-hook 'my-dired-imenu-init)
#+END_SRC

*** TODO History

- [ ] I would like to be able to browse the dired history. =helm-dired-history= could be useful for this, but I don't know how to use it to this end.

**** COMMENT helm-dired-history

#+BEGIN_SRC emacs-lisp
(use-package helm-dired-history
	:ensure t
	:init	
	(require 'savehist)
	(add-to-list 'savehist-additional-variables 'helm-dired-history-variable)
	(savehist-mode 1)
	
	:config
	(with-eval-after-load 'dired
		(require 'helm-dired-history) 
		;; if you are using ido,you'd better disable ido for dired
		;; (define-key (cdr ido-minor-mode-map-entry) [remap dired] nil) ;in ido-setup-hook
		)
	)
#+END_SRC

*** TODO size info 

- [ ] Does not work anymore?

Calculates the size of marked directories using =du=.
Copied from https://oremacs.com/2015/01/12/dired-file-size/ and slightly adapted.

#+BEGIN_SRC emacs-lisp
(defun dired-get-size ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-buffer
      (apply 'call-process "du" nil t nil "-sch" files)
      (message
       "Size of all marked files: %s"
       (progn
         (re-search-backward "\\(^[ 0-9.,]+[A-Za-z]+\\).*total$")
         (match-string 1))))))

(define-key dired-mode-map (kbd "z") 'dired-get-size)
#+END_SRC

** js2-mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode										; for improved JavaScript support
	:ensure t
	:mode
	("\\.js\\'" . js2-mode))
#+END_SRC

** org-mode

Must appear before LaTeX stuff!

http://pages.sachachua.com/.emacs.d/Sacha.html#orgfe5d909
http://doc.norang.ca/org-mode.html#Setup

*** Files

Org-mode files are usually bundled within a single directory stored in the variable =org-directory=. But if there are links to org-mode files outside =org-directory=, they should be included to =org-agenda-files=, too.

#+BEGIN_SRC emacs-lisp
(defun tl/update-org-agenda-files ()
	(interactive)
  (setq org-agenda-files ())
  (load-org-agenda-files-recursively (expand-file-name (concat org-directory "/"))) ; trailing slash required

	;; ;; The following code does not search the org directory recursively:
  ;; (setq org-agenda-files
	;; 			(append
	;; 			 (list org-directory)
	;; 			 (file-expand-wildcards (concat org-directory "/*/*.org"))))

	;; search for linked org-mode files within org-agenda-files and add them
	(save-current-buffer
		(dolist (file org-agenda-files)
			(find-file file)
			(add-links-to-org-agenda-files)   ; within the buffer of file
			))
	(switch-to-buffer (current-buffer))		; return to first buffer
	
	(customize-save-variable 'org-agenda-files org-agenda-files)
	(message "org-agenda-files updated")
	)
#+END_SRC

Search for org-mode files recursively:
#+BEGIN_SRC emacs-lisp
;; Modified http://stackoverflow.com/a/26548971/6452961
(require 'dash)
(defun load-org-agenda-files-recursively (dir) "Find all directories in DIR."
			 (unless (file-directory-p dir) (error "Not a directory `%s'" dir))
			 (unless (equal (directory-files dir nil org-agenda-file-regexp t) nil)
				 (setq org-agenda-files 
							 (append
								org-agenda-files
								(-filter 								; filter files with org-extension
								 (lambda (x) (not (string-match "#" x))) 
								 (file-expand-wildcards (concat dir "*.org"))))))
			 (dolist (file (directory-files dir nil nil t))
				 (unless (member file '("." ".."))
					 (let ((file (concat dir file "/")))
						 (when (file-directory-p file)
							 (load-org-agenda-files-recursively file)))))
			 )

;; set refile targets to move entries inside org-agenda 
(setq org-refile-targets '(
													 (nil :maxlevel . 2)             ; refile to headings in the current buffer
													 (org-agenda-files :maxlevel . 2) ; refile to any of these files
													 ))
#+END_SRC

Add linked org-mode files to =org-agenda-files=:
#+BEGIN_SRC emacs-lisp 
(defun add-links-to-org-agenda-files ()
	"Inspired by: http://stackoverflow.com/questions/38061773/add-linked-org-files-to-org-agenda-files"
	(interactive)
	(org-element-map  
			(org-element-parse-buffer)
			'link
		(lambda (x)
			(let ((org-link-path (org-element-property :path x))
						(org-link-type (org-element-property :type x)))
				(when (and (equal org-link-type "file") ; only links to files
									 (string-prefix-p "~/" org-link-path) ; relative paths are bad
									 (equal "org" (file-name-extension org-link-path)) ;only org-mode files
									 (file-exists-p org-link-path) ; only existing files
									 )
					(princ (concat " " org-link-path))
					(add-to-list 'org-agenda-files (expand-file-name org-link-path))
					)))))
#+END_SRC

*** Export

Use a less intrusive export interface:

#+BEGIN_SRC emacs-lisp
(setq org-export-dispatch-use-expert-ui t)
#+END_SRC

Note that the last export command on the current buffer can be reused with =C-u C-c C-e=. 

*** Archive

Preserves the first heading of the org-mode file (found in http://orgmode.org/worg/org-hacks.html#orgheadline59):

#+BEGIN_SRC emacs-lisp
(defadvice org-archive-subtree (around my-org-archive-subtree activate)
  (let ((org-archive-location
         (if (save-excursion (org-back-to-heading)
                             (> (org-outline-level) 1))
             (concat (car (split-string org-archive-location "::"))
                     "::* "
                     (car (org-get-outline-path)))
           org-archive-location)))
    ad-do-it))
#+END_SRC

*** babel

Preserve indentation in source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

Don't ask for confirmation when evaluating source blocks:
#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

*** General keys

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f9> c") 'org-goto-calendar)
  (global-set-key (kbd "<f9> a") 'org-agenda-list)
  (global-set-key (kbd "<f9> t") 'org-todo-list)
  (global-set-key (kbd "C-<f9>") 'org-cycle-agenda-files)
  (global-set-key (kbd "<f9> s") 'org-search-view)
  (global-set-key (kbd "<f9> f") 'org-search-view)
  (global-set-key (kbd "<f9> l") 'org-tags-view)
  (global-set-key (kbd "<f9> r") 'org-reload)
  (global-set-key (kbd "<f9> w")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/work/work.org"))))
  (global-set-key (kbd "<f9> n")
                  (lambda() (interactive)(find-file (concat org-notes-dir "/notes.org"))))
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c l") 'org-store-link)

  (with-eval-after-load 'org
    (define-key org-mode-map (kbd "C-<tab>") nil )
    (define-key org-mode-map (kbd "S-<up>") nil )
    (define-key org-mode-map (kbd "S-<down>") nil )
    (define-key org-mode-map (kbd "S-<left>") nil )
    (define-key org-mode-map (kbd "S-<right>") nil )
    (define-key org-mode-map (kbd "C-n") 'org-next-visible-heading )
		(define-key org-mode-map (kbd "C-p") 'org-previous-visible-heading )
    (define-key org-mode-map (kbd "C-c C-f") 'org-footnote-action )
		(define-key org-mode-map (kbd "C-c C-t") 'org-todo )
    (define-key org-mode-map (kbd "C-c C-x C-b") 'org-tree-to-indirect-buffer ))

  ;; (with-eval-after-load 'org-agenda
  ;;   (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+END_SRC

*** General appearence

**** Lists

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords 'org-mode
                        '(("^ +\\([-*]\\) "
                           (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

Allow for alphabetical list item labels:

#+BEGIN_SRC emacs-lisp
(setq org-list-allow-alphabetical t)
#+END_SRC

**** TODO Color text

- [ ] add support for export to LaTeX

Text can be colored using the link syntax, e.g. [[color:red][this is red]].
Taken from https://github.com/jkitchin/jmax/blob/master/org-colored-text.el
See also http://kitchingroup.cheme.cmu.edu/blog/2016/01/16/Colored-text-in-org-mode-with-export-to-HTML/

#+BEGIN_SRC emacs-lisp
(require 'org-colored-text)
#+END_SRC

**** Fonts

#+begin_src emacs-lisp
	(add-hook 'org-mode-hook (lambda ()
														 (variable-pitch-mode t)
														 ;; (text-scale-increase 0.5)
														 ))

	;; (set-face-attribute 'org-block-background nil :inherit 'fixed-pitch)

	(custom-set-faces
	 '(org-done ((t (:overline t))))
	 '(org-todo ((t (:overline t))))
	 '(org-block ((t (:inherit fixed-pitch :background "#3E3D31")))) ; org-mode >9
	 '(org-block-background ((t (:inherit fixed-pitch :background "#3E3D31"))))
	 '(org-block-begin-line ((t (:underline t))))
	 '(org-block-end-line  ((t (:overline t))))
	 '(org-level-1 ((t (:inherit outline-1 :overline t :weight semi-bold :height 1.5))))
	 '(org-level-2 ((t (:inherit outline-2 :overline t :weight semi-bold :height 1.25))))
	 '(org-level-3 ((t (:inherit outline-3 :weight semi-bold :height 1.1))))
	 '(org-level-4 ((t (:inherit outline-4 :weight semi-bold :height 1.0))))
	 '(org-level-5 ((t (:inherit outline-5 :weight semi-bold :height 1.0))))
	 )

	(with-eval-after-load 'org
		(set-face-attribute 'org-table nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-verbatim nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-latex-and-related nil :inherit 'fixed-pitch :background "#3E3D31")
		(set-face-attribute 'org-link nil :inherit 'fixed-pitch)
		(set-face-attribute 'org-date nil :inherit 'fixed-pitch)
		)

	(setq org-hide-emphasis-markers t)

#+end_src

**** Bullets, folding symbols, HTML and LaTeX symbols

Nicer bullets:

#+begin_src emacs-lisp
;; (use-package org-bullets
;; 	:ensure t
;; 	:init
;; 	(setq org-bullets-bullet-list
;; 				'("◉" "◎" "○" "●" "►" "♦" "◇"))
;; 	:config 
;; 	(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
;; 	)
#+end_src

Folding symbol:

#+begin_src emacs-lisp
(setq org-ellipsis " ▼")
#+end_src

Replace HTML/LaTeX code by UTF-8 characters (see org-pretty-entities for an enumeration):

#+begin_src emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

**** Editing

Do not edit in invisible areas of the buffer:

#+BEGIN_SRC emacs-lisp
(setq-default org-catch-invisible-edits 'show)
#+END_SRC

**** TODO Inline code 

- [ ] activate syntax highlighting for inline code

**** Checkboxes

Fontify checked checkbox items. 
(see https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html)

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

**** Math formulas

Toggle LaTeX images of math formulas when cursor is at point.

Taken from http://kitchingroup.cheme.cmu.edu/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment/

#+BEGIN_SRC emacs-lisp
(defvar org-latex-fragment-last nil
  "Holds last fragment/environment you were on.")

(defun org-latex-fragment-toggle ()
  "Toggle a latex fragment image "
  (and (eq 'org-mode major-mode)
       (let* ((el (org-element-context))
              (el-type (car el)))
         (cond
          ;; were on a fragment and now on a new fragment
          ((and
            ;; fragment we were on
            org-latex-fragment-last
            ;; and are on a fragment now
            (or
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type))
            ;; but not on the last one this is a little tricky. as you edit the
            ;; fragment, it is not equal to the last one. We use the begin
            ;; property which is less likely to change for the comparison.
            (not (= (org-element-property :begin el)
                    (org-element-property :begin org-latex-fragment-last))))
           ;; go back to last one and put image back
           (save-excursion
             (goto-char (org-element-property :begin org-latex-fragment-last))
             (org-preview-latex-fragment))
           ;; now remove current image
           (goto-char (org-element-property :begin el))
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov)))
           ;; and save new fragment
           (setq org-latex-fragment-last el))

          ;; were on a fragment and now are not on a fragment
          ((and
            ;; not on a fragment now
            (not (or
                  (eq 'latex-fragment el-type)
                  (eq 'latex-environment el-type)))
            ;; but we were on one
            org-latex-fragment-last)
           ;; put image back on
           (save-excursion
             (goto-char (org-element-property :begin org-latex-fragment-last))
             (org-preview-latex-fragment))
           ;; unset last fragment
           (setq org-latex-fragment-last nil))

          ;; were not on a fragment, and now are
          ((and
            ;; we were not one one
            (not org-latex-fragment-last)
            ;; but now we are
            (or
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type)))
           (goto-char (org-element-property :begin el))
           ;; remove image
           (let ((ov (loop for ov in (org--list-latex-overlays)
                           if
                           (and
                            (<= (overlay-start ov) (point))
                            (>= (overlay-end ov) (point)))
                           return ov)))
             (when ov
               (delete-overlay ov)))
           (setq org-latex-fragment-last el))))))

;; (add-hook 'post-command-hook 'org-latex-fragment-toggle)
#+END_SRC

Toggle =org-latex-fragment-toggle=:
#+BEGIN_SRC emacs-lisp
(defun org-latex-fragment-toggle-toggle ()
	(interactive)
	(if (memq 'org-latex-fragment-toggle (default-value 'post-command-hook))
			(progn 
				(remove-hook 'post-command-hook 'org-latex-fragment-toggle)
				(org-remove-latex-fragment-image-overlays))
		(add-hook 'post-command-hook 'org-latex-fragment-toggle)
		(org-toggle-latex-fragment '(16))) 	; equivalent to: C-u C-u org-toggle-latex-fragment
	)
#+END_SRC

*** Modules

See http://orgmode.org/worg/org-contrib/

#+BEGIN_SRC emacs-lisp
;; (setq org-modules '( ;; org-bbdb
;;                       ;; org-gnus
;;                       ;; org-drill
;;                       ;; org-info
;;                       ;; org-jsinfo
;;                       ;; org-habit
;;                       ;; org-irc
;;                       ;; org-mouse
;;                       ;; org-protocol
;;                       ;; org-annotate-file
;;                       ;; org-eval
;;                       ;; org-expiry
;;                       ;; org-interactive-query
;;                       ;; org-man
;;                       ;; org-collector
;;                       ;; org-panel
;;                       ;; org-screen
;;                       ;; org-toc
;; 											))
;; (eval-after-load 'org
;;  '(org-load-modules-maybe t))
;; (setq org-expiry-inactive-timestamps t)
#+END_SRC

*** Miscellaneous settings

Selection
#+BEGIN_SRC emacs-lisp
(setq org-support-shift-select t)
#+END_SRC

Source blocks
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t
			org-src-tab-acts-natively t)
#+END_SRC

Todo lists
#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
#+END_SRC

Links
#+BEGIN_SRC emacs-lisp
(setq org-return-follows-link t)
#+END_SRC

Block
#+BEGIN_SRC emacs-lisp
(setq org-hide-block-startup t) 				; hide blocks at startup
#+END_SRC

Indent automatically
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

Support for inline tasks
#+BEGIN_SRC emacs-lisp
(load "org-inlinetask")
(define-key org-mode-map (kbd "C-c C-x C-t") 'org-inlinetask-insert-task)
#+END_SRC

C-a and C-e behave org-sensitive
#+BEGIN_SRC emacs-lisp
(setq org-special-ctrl-a/e t)
#+END_SRC

*** Clocking and logging

Collect log entries in drawer:
#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer t)
#+END_SRC

*** TODO Newline

Don't split the line with =M-<return>=:
#+BEGIN_SRC emacs-lisp
(setq org-M-RET-may-split-line '((default . nil)))
#+END_SRC

The following is taken from [[http://github.com/jkitchin/scimax/blob/master/scimax-org.el]] . 
See also http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/ .

I modified the code in some details.

- [ ] Where to include =org-table-wrap-region=?
- [ ] Problem with list items: formulas are not recognized as content

#+BEGIN_SRC emacs-lisp
(require 'org-inlinetask)

(defun scimax/org-return (&optional ignore)
  "Add new list item, heading or table row with RET.
A double return on an empty element deletes it.
Use a prefix arg to get regular RET. "
  (interactive "P")
  (if ignore
      (org-return)
    (cond

     ((eq 'line-break (car (org-element-context)))
      (org-return-indent))

     ;; Open links like usual, unless point is at the end of a line.
     ;; and if at beginning of line, just press enter.
     ((or (and (eq 'link (car (org-element-context))) (not (eolp)))
					(bolp))
      (org-return))

     ;; It doesn't make sense to add headings in inline tasks. Thanks Anders
     ;; Johansson!
     ((org-inlinetask-in-task-p)
      (org-return))

     ;; checkboxes too
     ((org-at-item-checkbox-p)
      (org-insert-todo-heading nil))

     ;; lists end with two blank lines, so we need to make sure we are also not
     ;; at the beginning of a line to avoid a loop where a new entry gets
     ;; created with only one blank line.
     ((org-in-item-p)
      ;; (if (save-excursion (beginning-of-line) (org-element-property :contents-begin (org-element-context)))
			(if (org-element-property :contents-end (org-element-context)) ; added by TL
					(if (not (re-search-forward "[[:graph:]]" (line-end-position) t)) ; added by TL: use org-return when character follows in line
							(org-insert-heading)
						(org-return))								; added by TL
				(beginning-of-line)
				(delete-region (line-beginning-position) (line-end-position))
				(org-return)))

     ;; org-heading
     ((org-at-heading-p)
      (if (not (string= "" (org-element-property :title (org-element-context))))
					(if (not (re-search-forward "[[:graph:]]" (line-end-position) t)) ; added by TL: use org-return when character follows in line
							(progn (org-end-of-meta-data)
										 ;; (org-insert-heading-respect-content) ; commented by TL: heading is sometimes added after *next* heading.
										 (org-insert-heading) ; added by TL
										 (outline-show-entry))
						(org-return))								; added by TL
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")))

     ;; tables
     ((org-at-table-p)
      (if (-any?
					 (lambda (x) (not (string= "" x)))
					 (nth
						(- (org-table-current-dline) 1)
						(remove 'hline (org-table-to-lisp))))
					(org-return)
				;; empty row
				(beginning-of-line)
				(setf (buffer-substring
							 (line-beginning-position) (line-end-position)) "")
				(org-return)))

     ;; fall-through case
     (t
      (org-return)))))
#+END_SRC

Here's my own version, which uses =org-table-wrap-region=. This was superseded by =scimax/org-return=.

#+BEGIN_SRC emacs-lisp
(defun tl/org-return ()
	(interactive)
	(cond
	 ;; in org-table
	 ((org-table-p)
		(let ((home (point)))
			(when (not (looking-at ".*\|")) ; right of the rightmost vertical bar?
				(if (and (looking-at "[[:space:]]*$")	; empty cell?
								 (looking-back "\|[[:space:]]*"))
						(progn											; true: use org-return
							(org-return)
							(t))
					(end-of-line)									; false: insert new table row
					(insert "\|")
					(org-table-insert-row t)
					(goto-char home)))
			(org-table-wrap-region nil)				; only works in cells embraced by vertical bars
			))
	 ;; else
	 (t (org-return))
	 )
  )

(defun tl/org-shift-return ()
	(interactive)
  (cond
	 ;; in org-table
	 ((org-table-p)
		(org-return))
	 ;; else
	 (t (smart-open-line))
	 )
  )
#+END_SRC

Set keys:

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
	(define-key org-mode-map (kbd "<return>") 'scimax/org-return) ; not org-table-next-row
	(define-key org-mode-map (kbd "S-<return>") 'tl/org-shift-return )) ; not org-table-copy-down
#+END_SRC

*** LaTeX support

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((latex . t)))
(setq org-highlight-latex-and-related '(latex script entities)) ; inline sytax highlighting
;; (add-to-list 'org-latex-packages-alist '("" "tikz" t))					; unfortunately this breaks the color of fonts in inline previews
;; (add-to-list 'org-latex-packages-alist '("" "forest" t))
#+END_SRC

Scale LaTeX previews:
#+BEGIN_SRC emacs-lisp
;; static
;; (plist-put org-format-latex-options :scale 2) ; scale inline PNGs

;; dynamic (http://emacs.stackexchange.com/a/13032/12336)
(defun update-org-latex-fragment-scale ()
  (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
    (plist-put org-format-latex-options :scale (* 2.3 text-scale-factor)))
)
(add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale)
#+END_SRC

Use LaTeXmk:
#+BEGIN_SRC emacs-lisp
(setq org-latex-to-pdf-process (list "latexmk -f -pdf %s"))
#+END_SRC

*** COMMENT org-gcal

Integrate Google Calendar with =org-gcal=.
I don't use =org-gcal= any more.

#+BEGIN_SRC emacs-lisp
	(setq package-check-signature nil)

	(use-package org-gcal
		:ensure t
		:config
		(when (load-file (expand-file-name "gcal-credentials.el" private-emacs-settings-dir))
			(setq org-gcal-client-id my-org-gcal-client-id
						org-gcal-client-secret my-org-gcal-client-secret
						org-gcal-file-alist '((my-gmail-address .  (concat org-notes-dir "gcal.org"))))
	))
#+END_SRC

*** org-ref

- [X] =org-ref-prefer-bracket-links= does not work?
- [X] =org-ref-cite-color= is not used 

#+BEGIN_SRC emacs-lisp
;; (setq org-ref-completion-library 'org-ref-ivy-cite) ; must appear before org-ref
(use-package org-ref
	:ensure t
	:after org
	:init
	(require 'org-ref) 										; don't know why I need this
	(setq org-ref-default-bibliography (list user-bibliography-file)
				;; org-ref-bibliography-notes "~/bibliography/notes.org"
				org-ref-pdf-directory user-bibliography-pdf-dir
				org-ref-prefer-bracket-links t
				)
	:config
	:bind (:map org-mode-map
							("C-c ]" . org-ref-helm-insert-cite-link)
							("C-c )" . org-ref-helm-insert-ref-link)
							("C-c (" . org-ref-helm-insert-label-link))
)
#+END_SRC

Add \citeauthoryear and  \citealtauthoryear to org-ref:
#+BEGIN_SRC emacs-lisp
(org-ref-define-citation-link "citeauthoryear")
(add-to-list 'org-ref-cite-types "citeauthoryear")
(org-ref-define-citation-link "citealtauthoryear")
(add-to-list 'org-ref-cite-types "citealtauthoryear")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(org-ref-label-color "magenta")
 '(org-ref-ref-color "LimeGreen")
 '(org-ref-cite-color "ForestGreen")
 )
#+END_SRC

*** org-reveal

#+BEGIN_SRC emacs-lisp
(use-package ox-reveal
	:ensure ox-reveal)

;; (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-root "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.4.1/")
(setq org-reveal-mathjax t)

(use-package htmlize
	:ensure t)
#+END_SRC

*** org-show

Simple interactive presentations from within Emacs.
See https://github.com/jkitchin/jmax/blob/master/org/org-show.org for more information.

#+BEGIN_SRC emacs-lisp
(require 'org-show) 
#+END_SRC

*** TODO org-beamer

- [ ] add export of text colored with `color:` links (see [[*Color text][Color text]])

Documentation:
- https://github.com/fniessen/refcard-org-beamer
- http://orgmode.org/tmp/worg/org-tutorials/org-latex-export.html

Load support for exporting LaTeX beamer presentations:
#+BEGIN_SRC emacs-lisp
(require 'ox-beamer)
#+END_SRC

Add my beamer class (tl-beamer) to the known LaTeX classes:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
         '("tl-beamer" 
						"\\documentclass{preambles/tl-beamer}
						[NO-DEFAULT-PACKAGES]"
            ("\\section{%s}" . "\\section*{%s}")
            ("\\subsection{%s}" . "\\subsection*{%s}")
            ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
            ("\\paragraph{%s}" . "\\paragraph*{%s}")
            ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

Change export of bold font:
#+BEGIN_SRC emacs-lisp
(defun my-beamer-bold (contents backend info)
  (when (eq backend 'beamer)
    (replace-regexp-in-string "\\`\\\\[A-Za-z0-9]+" "\\\\textbf" contents)))

(add-to-list 'org-export-filter-bold-functions 'my-beamer-bold)
#+END_SRC

*** Graphviz/dot support

 #+BEGIN_SRC emacs-lisp
(add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
(org-babel-do-load-languages  'org-babel-load-languages '((dot . t)))
#+END_SRC

*** TODO Gnuplot support

- [ ] compiling Gnuplot source blocks crashes Emacs

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((gnuplot . t)))
#+END_SRC

*** R support

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '((R . t)))
(setq org-babel-R-command "R --slave --no-save")
#+END_SRC

*** Plantuml

http://eschulte.github.io/babel-dev/DONE-integrate-plantuml-support.html

 #+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages  'org-babel-load-languages '((plantuml . t)))
#+END_SRC

*** Spell checking
#+BEGIN_SRC emacs-lisp
;; ispell
(add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
(add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
;; flyspell
;; http://emacs.stackexchange.com/a/9347/12336
;; NO spell check for embedded snippets
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let ((rlt ad-return-value)
        (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\)")
        (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\)")
        old-flag
        b e)
    (when ad-return-value
      (save-excursion
        (setq old-flag case-fold-search)
        (setq case-fold-search t)
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t)))
        (setq case-fold-search old-flag))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

*** Agenda

Don't split window when opening agenda:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup "only-window")
#+END_SRC

Show notifications of agenda events:
#+BEGIN_SRC emacs-lisp
(use-package org-alert
	:ensure t
	)
#+END_SRC

Customize agenda view:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
			'(("w" "Agenda and work-related tasks"
				 ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
								 (org-agenda-overriding-header "High-priority tasks:")))
					(agenda "")
					(todo "NEXT"
								((org-agenda-overriding-header "Normal-priority tasks:")))
					(todo "WAITING" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					(todo "TODO" ((org-agenda-overriding-header "")
												(org-agenda-block-separator nil)))
					(todo "SOMEDAY" ((org-agenda-overriding-header "")
													 (org-agenda-block-separator nil)))
					;; (tags-todo "@work"
					;; 					 ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("NEXT")))
					;; 						(org-agenda-overriding-header "")
					;; 						(org-agenda-block-separator nil)))
					)
				 ((org-agenda-tag-filter-preset '("+@work")))
				)))

(defun org-agenda-list-work ()
	(interactive)
	(org-agenda nil "w"))

#+END_SRC

Sort agenda TODOs with =org-agenda-sorting-strategy=.

Make the block agenda more compact:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-compact-blocks nil)
#+END_SRC

Change the separator between blocks in agenda:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-block-separator ?\-)
#+END_SRC

Start the weekly agenda today:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-start-on-weekday nil)
#+END_SRC

Agenda remains open in background. No need to recompile it every time you call it:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-sticky t)
#+END_SRC

Show tags at the right edge of the screen:
#+BEGIN_SRC emacs-lisp
(setq org-agenda-tags-column (- (- (window-total-width) 3)))
#+END_SRC

*** Links

Add some link types:
#+BEGIN_SRC emacs-lisp
(setq org-link-abbrev-alist '(("att" . org-attach-expand-link)))
(setq org-link-abbrev-alist '(("attachment" . org-attach-expand-link)))
#+END_SRC

Links to files are opened in the same window, i.e. the window does not get split:
#+BEGIN_SRC emacs-lisp
(setq org-link-frame-setup '((file . find-file)))
#+END_SRC

Show whether links to files are valid:
#+BEGIN_SRC emacs-lisp
;; taken from https://emacs.stackexchange.com/a/33078/12336
(org-link-set-parameters
 "file"
 :face (lambda (path) (when (not (file-remote-p path))(if (file-exists-p path) 'org-link 'org-warning))))
#+END_SRC

*** Tags

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist
			'((:startgroup . nil)
				("@work" . ?w)
				(:grouptags . nil)
				("management" . ?m)
				("teaching" . ?t)
				("research" . ?r)
				("event" . ?e)
				(:endgroup . nil)

				(:startgroup . nil)
				("research" . ?r)
				(:grouptags . nil)
				("parsing" . nil)
				("linguistics" . nil)
				("formalisms" . nil)
				("philosophy" . nil)
				("logic" . nil)
				("maths" . nil)
				("computerScience" . nil)
				("CL" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("event" . ?e)
				(:grouptags . nil)
				("talk" . nil)									
				("workshop" . nil)
				("publication" . nil)
				("conference" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("management" . ?m)
				(:grouptags . nil)
				("proposal" . nil)									
				("project" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("linguistics" . ?h)
				(:grouptags . nil)
				("syntax" . nil)
				("semantics" . nil)
				("pragmatics" . nil)
				("phonology" . nil)
				("morphology" . nil)
				("corpora" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("computationalLinguistics" . ?h)
				(:grouptags . nil)
				("parsing" . nil)
				("generation" . nil)
				("formalisms" . nil)
				("corpora" . nil)
				("speechRecognition" . nil)
				("machineLearning" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("@home" . ?h)
				(:grouptags . nil)
				("spenden" . nil)
				(:endgroup . nil)

				(:startgroup . nil)
				("software" . ?h)
				(:grouptags . nil)
				("programming" . nil)
				("nlp" . nil)
				("os" . nil)
				("xmg" . nil)											
				(:endgroup . nil)

				(:startgroup . nil)
				("programming" . ?p)
				(:grouptags . nil)
				("emacs" . ?m)
				("latex" . ?x)
				("langsci" . ?l)
				("python" . ?y)
				("javascript" . ?j)
				("perl" . nil)
				("php" . nil)
				("shellscript" . nil)											
				(:endgroup . nil)
				))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-c :") 'org-set-tags)
#+END_SRC

*** Tables

Some functions to select and copy columns (http://emacs.stackexchange.com/a/28298/12336)
#+BEGIN_SRC emacs-lisp
(defun org-table-goto-col-beginning ()
  "Go to beginning of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (org-table-begin))
    (org-table-goto-column col))
  (point))

(defun org-table-col-beginning ()
  "Return beginning position of current column."
  (save-excursion
    (org-table-goto-col-beginning)))

(defun org-table-goto-col-end ()
  "Goto end of current column and return `point'."
  (interactive)
  (assert (org-table-p) "Not in org-table.")
  (org-table-align)
  (let ((col (org-table-current-column)))
    (goto-char (1- (org-table-end)))
    (org-table-goto-column col)
    (skip-chars-forward "^|"))
  (point))

(defun org-table-col-end ()
  "Return end position of current column."
  (save-excursion
    (org-table-goto-col-end)))

(defun org-table-select-col ()
  "Select current column."
  (interactive)
  (set-mark (org-table-col-beginning))
  (org-table-goto-col-end))

(defun org-table-copy-col ()
  "Copy current column."
  (interactive)
  (save-excursion
    (org-table-copy-region (org-table-goto-col-beginning)
													 (org-table-goto-col-end))))
#+END_SRC

Functions to move around single cells:
#+BEGIN_SRC emacs-lisp
(require 'org-table-move-single-cell)
#+END_SRC

*** Capture templates

- Template expansions: http://orgmode.org/manual/Template-expansion.html

#+BEGIN_SRC emacs-lisp
	(setq org-capture-templates
				'(
					("a" "Appointment" entry (file (concat org-directory "/captures.org"))
					 "* APPT %?\t%^G\n\n%^T\n\n")
					;; ;; used for org-gcal
					;; ("a" "Appointment" entry (file (concat org-directory "/gcal.org"))
					;;  "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
					("t" "Todo" entry (file (concat org-directory "/captures.org"))
					 "* TODO %?\t%^G\n CREATED: %U\n About region:%i\n %a")
					("n" "Note" entry (file+datetree (concat org-directory "/notes.org"))
					 "* %?\t%^G\n CREATED: %U\n About region:%i\n %a")
					("c" "Code" entry (file (concat org-directory "/code.org"))
					 "* %?\t%^G\n#+BEGIN_SRC %^{language}\n\n#+END_SRC\n CREATED: %U\n About region:%i\n %a")
					))

	;; (global-set-key (kbd "<f9> <f9>") 'org-capture)
	;; (global-set-key (kbd "<f9> <f9> t") (lambda () (interactive) (org-capture nil "t")))
#+END_SRC

*** Todo keywords

From the org-mode documentation (http://orgmode.org/worg/doc.html#org-todo-keywords):
#+BEGIN_QUOTE
"WAIT(w@/!)".  "@" means to add a note (with time), "!" means to record only the time of the state change.  With X and Y being either "@" or "!", "X/Y" means use X when entering the state, and use Y when leaving the state if and only if the *target* state does not define X.  You may omit any of the fast-selection key or X or /Y, so WAIT(w@), WAIT(w/@) and WAIT(@/@) are all valid.
#+END_QUOTE

- TODO: something that needs to be done, maybe now, maybe later. 
- NEXT: something that can be done /now/. There's everything you need to start doing it.
- APPT: appointment (meeting, phone call etc.) with a fixed date.
- WAITING: something that cannot be done now, because some prerequisites are not yet met.
- HOLD: something that cannot be done now, and the prerequisites are unlikely to be fullfilled in the future.
- SOMEDAY: you are not yet sure whether this needs to be done.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      (quote ((sequence "TODO(t!)" "NEXT(n)" "APPT(a)" "|" "DONE(d)")
              (sequence "WAITING(w@/!)" "HOLD(h@/!)" "SOMEDAY(s)" "|" "CANCELLED(c@/!)"))))

(setq org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("HOLD" :foreground "magenta" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)
              ("APPT" :foreground "forest green" :weight bold)
							("SOMEDAY" :foreground "forest green" :weight bold)
							)))
#+END_SRC

Fast TODO selection:
#+BEGIN_SRC emacs-lisp
(setq org-use-fast-todo-selection t)
#+END_SRC

Insert timestamp when task is marked as DONE:
#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

Insert timestamp when changing deadline:
#+BEGIN_SRC emacs-lisp
(setq org-log-redeadline 'time)
#+END_SRC

Insert timestamp when changing schedule:
#+BEGIN_SRC emacs-lisp
(setq org-log-reschedule 'time)
#+END_SRC

** Calendar

#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)

  (setq calendar-intermonth-text
        '(propertize
          (format "%2d"
                  (car
                   (calendar-iso-from-absolute
                    (calendar-absolute-from-gregorian (list month day year)))))
          'font-lock-face 'font-lock-warning-face))

  (setq calendar-intermonth-header
        (propertize "KW"                  ; or e.g. "KW" in Germany
                    'font-lock-face 'font-lock-keyword-face))

#+END_SRC

*** German holidays

#+BEGIN_SRC emacs-lisp
  (use-package german-holidays
    :ensure t
    :config
    (setq calendar-holidays holiday-german-holidays)
    ;; (setq calendar-holidays holiday-german-BW-holidays)
    )
#+END_SRC

*** calfw 

http://jameswilliams.be/blog/2016/01/11/Taming-Your-GCal.html

 #+BEGIN_SRC emacs-lisp
(use-package calfw
	:ensure t 
	:init

	(use-package calfw-org
		:ensure t)
	(use-package calfw-ical
		:ensure t)

	(setq cfw:render-line-breaker 'cfw:render-line-breaker-simple)

	(defvar user-calendar-settings-file
		(expand-file-name "calendar-calfw-settings.el" private-emacs-settings-dir))

	(if (file-exists-p user-calendar-settings-file)
			(load-file user-calendar-settings-file)
		(display-warning "calfw" (concat "Could not load " user-calendar-settings-file)))
	)

(define-key cfw:calendar-mode-map (kbd "u") 
	'(lambda () (interactive)
		 (when (fboundp 'tl/update-my-calendars) ; tl/update-my-calendars is defined in  user-calendar-settings-file
			 (tl/update-my-calendars))
		 (my-open-calfw)
		 ))

#+END_SRC

** LaTeX

*** TODO AUCTeX 

- [ ] How to do completion of custom macros?
  
#+BEGIN_SRC emacs-lisp
(use-package tex
	:ensure auctex												; because auctex overwrites tex

	:init

	;; to activate auctex
	(setq TeX-auto-save t)  
	(setq TeX-auto-local
				(expand-file-name "temp" user-emacs-directory))
	(setq TeX-parse-self t)
	(setq-default TeX-master nil)
	(setq TeX-save-query nil) ; autosave before compiling 

	;; Show compilation log
	(setq TeX-show-compilation nil) ; always show and follow TeX output
	;; FIXME: Make C-c C-l behave like this
	(setq compilation-scroll-output t)

	;; don't indent
	(setq LaTeX-indent-level 0)
	(setq LaTeX-item-indent 0)

	;; viewer
	(setq TeX-PDF-mode t)
	(setq TeX-source-correlate-mode t)
	(setq TeX-source-correlate-method 'synctex)

	(when (eq system-type 'windows-nt) 
		(setq TeX-view-program-list
					'(("Sumatra PDF" ("\"SumatraPDF.exe\" -reuse-instance"
														(mode-io-correlate " -forward-search %b %n ") " %o"))))
		(eval-after-load 'tex
			'(progn
				 (assq-delete-all 'output-pdf TeX-view-program-selection)
				 (add-to-list 'TeX-view-program-selection '(output-pdf "Sumatra PDF"))))
		)
	
	;; set up engines
	(setq TeX-engine-alist 
				'(
					(xetex "XeTeX" 
								 "xetex --file-line-error" 
								 "xelatex --file-line-error" 
								 "xetex")
					(xetex_sh "XeTeX shell escape" 
										"xetex --file-line-error --shell-escape" 
										"xelatex --file-line-error --shell-escape" 
										"xetex")))

	;; make LaTeXmk default
	(use-package auctex-latexmk
		:ensure t
		:config
		(auctex-latexmk-setup)
		(setq auctex-latexmk-inherit-TeX-PDF-mode t)
		(setq TeX-command-force "LatexMk")  ; remember to set path variable accordingly!
		)
	
	:config
	;; font keys
	(defun TeX-italic()
		(interactive)
		(TeX-font nil ?\C-i))
	(defun TeX-bold()
		(interactive)
		(TeX-font nil ?\C-b))
	(defun TeX-typewriter()
		(interactive)
		(TeX-font nil ?\C-t))
	(defun TeX-emphasis()
		(interactive)
		(TeX-font nil ?\C-e))
	(defun TeX-smallcaps()
		(interactive)
		(TeX-font nil ?\C-c))
	(defun TeX-italic-replace()
		(interactive)
		(TeX-font t ?\C-i))
	(defun TeX-bold-replace()
		(interactive)
		(TeX-font t ?\C-b))
	(defun TeX-typewriter-replace()
		(interactive)
		(TeX-font t ?\C-t))
	(defun TeX-emphasis-replace()
		(interactive)
		(TeX-font t ?\C-e))
	(defun TeX-smallcaps-replace()
		(interactive)
		(TeX-font t ?\C-c))
	(defun TeX-deletefont()
		(interactive)
		(TeX-font nil ?\C-d))
	(define-key LaTeX-mode-map (kbd "C-c C-f i") 'TeX-italic)
	(define-key LaTeX-mode-map (kbd "C-c C-f b") 'TeX-bold)
	(define-key LaTeX-mode-map (kbd "C-c C-f t") 'TeX-typewriter)
	(define-key LaTeX-mode-map (kbd "C-c C-f e") 'TeX-emphasis)
	(define-key LaTeX-mode-map (kbd "C-c C-f s") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c C-f c") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c C-f d") 'TeX-deletefont)	
	(define-key LaTeX-mode-map (kbd "C-c C-f DEL") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c f i") 'TeX-italic)
	(define-key LaTeX-mode-map (kbd "C-c f b") 'TeX-bold)
	(define-key LaTeX-mode-map (kbd "C-c f t") 'TeX-typewriter)
	(define-key LaTeX-mode-map (kbd "C-c f e") 'TeX-emphasis)
	(define-key LaTeX-mode-map (kbd "C-c f s") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c f c") 'TeX-smallcaps)
	(define-key LaTeX-mode-map (kbd "C-c f d") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c f DEL") 'TeX-deletefont)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! i") 'TeX-italic-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! b") 'TeX-bold-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! t") 'TeX-typewriter-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! e") 'TeX-emphasis-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! s") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c C-f ! c") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! i") 'TeX-italic-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! b") 'TeX-bold-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! t") 'TeX-typewriter-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! e") 'TeX-emphasis-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! s") 'TeX-smallcaps-replace)
	(define-key LaTeX-mode-map (kbd "C-c f ! c") 'TeX-smallcaps-replace)

	;; activate folding
	(add-hook 'LaTeX-mode-hook (lambda ()
															 (TeX-fold-mode 1)
															 ;; (TeX-fold-buffer)
															 ))
	;; folding behavior for environments
	(custom-set-variables '(TeX-fold-env-spec-list
													'(("[comment]" ("comment"))
														("[figure]" ("figure"))
														("[tikz]" ("tikzpicture")))))


	:bind (:map  LaTeX-mode-map
							 ;; ("C-l C-q" . align-current) ; useful command to align arrays
							 ;; ("C-l H-i" . align-current) ; useful command to align arrays							 
							 ;; keys for error browsing (disabled; see hydra settings)
							 ;; ("<f4>" . TeX-next-error)	 
							 ;; ("S-<f4>" . TeX-previous-error)
							 ;; ("C-<f4>" . TeX-error-overview)
							 ;; miscellaneous keys
							 ("C-c <backspace>" . TeX-clean)
							 ("C-<return>" . LaTeX-close-environment)
							 ;; goto keys
							 ("C-c {" . LaTeX-find-matching-begin)
							 ("C-c }" . LaTeX-find-matching-end)
							 ;; ("C-c C-l" . (lambda () (interactive) ()))  ;FIXME
							 )
	)
#+END_SRC

*** TODO reftex

- [ ] =\section=, =\frametitle= etc. are not shown in TOC when not being line-inital.

#+BEGIN_SRC emacs-lisp
(use-package reftex
	:diminish reftex-mode
	:init
	(add-hook 'latex-mode-hook 'turn-on-reftex)
	(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
	(setq reftex-plug-into-AUCTeX t
				;; reftex-ref-style-default-list '("Cleveref" "Hyperref" "Fancyref")
				;; reftex-toc-split-windows-horizontally t
				reftex-ref-macro-prompt nil			; go straight to the labels when referencing
				reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")
				reftex-default-bibliography (list user-bibliography-file)
				)

	;; add frametitle to TOC
	(setq reftex-section-levels '(("part" . 0)
																("chapter" . 1)
																("section" . 2)
																("subsection" . 3)
																("subsubsection" . 4)
																("frametitle" . -3)
																("paragraph" . 5)
																("subparagraph" . 6)
																("addchap" . -1)
																("addsec" . -2)))
	
	;; connect reftex to imenu
	(add-hook 'reftex-load-hook 'imenu-add-menubar-index)
	(add-hook 'reftex-mode-hook 'imenu-add-menubar-index)

	;; isearch across files
	(add-hook 'reftex-mode-hook  (lambda () (reftex-isearch-minor-mode)))
	
	:config
	
	;; jumping around like in org-mode
	(define-key LaTeX-mode-map (kbd "C-c C-j") 'tl/reftex-in-follow-mode)
	(define-key LaTeX-mode-map (kbd "C-n") 'tl/reftex-next)
	(define-key LaTeX-mode-map (kbd "C-p") 'tl/reftex-previous)
	(defun tl/reftex-in-follow-mode()
		(interactive)
		(setq reftex-toc-follow-mode t)
		(reftex-toc))
	(defun tl/reftex-next ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-next)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	(defun tl/reftex-previous ()
		(interactive)
		(next-line)														; no clue why this is necessary
		(tl/reftex-in-follow-mode)
		(reftex-toc-previous)
		(reftex-toc-goto-line-and-hide)
		(recenter))
	
	:bind (:map LaTeX-mode-map
							("C-c ]" . reftex-citation); same as in org-mode
						  ) 
	)
#+END_SRC

*** bibtex

Align at equal sign instead of field text:
#+BEGIN_SRC emacs-lisp
(setq bibtex-align-at-equal-sign t)
#+END_SRC

*** TODO helm-bibtex

On the long run, this is supposed to help to replace JabRef.
See also https://nickhigham.wordpress.com/2016/01/06/managing-bibtex-files-with-emacs/

- [ ] see  pull request: https://github.com/tmalsburg/helm-bibtex/pull/113

#+BEGIN_SRC emacs-lisp
(use-package helm-bibtex
	:ensure t
	:config
	(setq bibtex-completion-bibliography (list user-bibliography-file))
	(setq bibtex-completion-additional-search-fields '(bibtexkey))
	;; The standard function with modified default action  
	;; :bind (:map LaTeX-mode-map ("C-l C-r" . helm-bibtex-with-local-bibliography))
	)
#+END_SRC

*** COMMENT ivy-bibtex

#+BEGIN_SRC emacs-lisp
		;; ;; ivy-bibtex
		;; (use-package ivy-bibtex
		;; 	:ensure t
		;; 	:config
		;; 	;; (setq bibtex-completion-bibliography '("./references.bib"))
		;; 	(setq bibtex-completion-additional-search-fields '(bibtexkey))
		;; 	;; (define-key LaTeX-mode-map (kbd "C-l C-r") 'ivy-bibtex)
		;; 	;; The standard function with modified default action  
		;; 	(defun ivy-bibtex (&optional arg)
		;; 		"Search BibTeX entries using ivy. With a prefix ARG the cache is invalidated and the bibliography reread."
		;; 		(interactive "P")
		;; 		(when arg
		;; 			(setq bibtex-completion-bibliography-hash ""))
		;; 		(bibtex-completion-init)
		;; 		(ivy-read "BibTeX Items: "
		;; 							(bibtex-completion-candidates 'ivy-bibtex-candidates-formatter)
		;; 							:caller 'ivy-bibtex
		;; 							:action 'bibtex-completion-insert-key))
		;; 	;; look for local bibliographies
		;; 	;; (require 'ebib)
		;; 	(defun ivy-bibtex-with-local-bibliography ()
		;;     (interactive)
		;;     (let ((bibtex-completion-bibliography
		;; 					 (if (eq major-mode 'latex-mode)
		;; 							 ;; (ebib--get-local-databases)
		;; 							 (bibtex-completion--get-local-databases)
		;; 						 bibtex-completion-bibliography)))
		;; 			(ivy-bibtex)))
		;; 	;; proposal by jagrg: https://github.com/tmalsburg/helm-bibtex/issues/112 
		;; 	(defun bibtex-completion--get-local-databases ()
		;; 		"Return a list of .bib files associated with the current file."
		;; 		(let ((texfile nil)
		;; 					(cb (current-buffer)))
		;; 			(when (and (boundp 'TeX-master)
		;; 								 (stringp TeX-master))
		;; 				(setq texfile (if (file-name-extension TeX-master)
		;; 													TeX-master
		;; 												(concat TeX-master ".tex"))))
		;; 			(with-temp-buffer
		;; 				(if (and texfile (file-readable-p texfile))
		;; 						(insert-file-contents texfile)
		;; 					(insert-buffer-substring cb))
		;; 				(save-match-data
		;; 					(goto-char (point-min))
		;; 					(cond
		;; 					 ;; bibtex
		;; 					 ((re-search-forward "\\\\\\(?:no\\)*bibliography{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(split-string (match-string-no-properties 1) ",[ ]*")))
		;; 					 ;; biblatex
		;; 					 ((re-search-forward "\\\\addbibresource\\(\\[.*?\\]\\)?{\\(.*?\\)}" nil t)
		;; 						(mapcar (lambda (fname)
		;; 											(if (file-name-extension fname)
		;; 													fname
		;; 												(concat fname ".bib")))
		;; 										(let ((option (match-string 1))
		;; 													(file (match-string-no-properties 2)))
		;; 											(unless (and option (string-match-p "location=remote" option))
		;; 												(split-string file ",[ ]*")))))
		;; 					 (t
		;; 						bibtex-completion-bibliography))))))
		;; 	:bind (:map LaTeX-mode-map 
		;; 							("C-l C-r" . ivy-bibtex-with-local-bibliography))
		;; 	)
#+END_SRC

*** Beamer

Add \frametitle to outline (and imenu):
#+BEGIN_SRC emacs-lisp
(add-to-list 'TeX-outline-extra '("\\\\frametitle\\b" 4))
#+END_SRC

*** Misc

Make square brackets indent correctly (testing):
#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?\[ "(]" LaTeX-mode-syntax-table)
(modify-syntax-entry ?\] ")[" LaTeX-mode-syntax-table)
#+END_SRC

Delete macro at point (http://emacs.stackexchange.com/a/7997/12336):
#+BEGIN_SRC emacs-lisp
(defun TeX-delete-macro ()
  "Remove current macro and return `t'.  If no macro at point,
return `nil'."
  (interactive)
  (when (TeX-current-macro)
    (let ((bounds (TeX-find-macro-boundaries))
          (brace  (save-excursion
                    (goto-char (1- (TeX-find-macro-end)))
                    (TeX-find-opening-brace))))
      (delete-region (1- (cdr bounds)) (cdr bounds))
      (delete-region (car bounds) (1+ brace)))
    t))
#+END_SRC

Delete environment at point (https://www.reddit.com/r/emacs/comments/5f99nv/help_with_auctex_how_to_delete_an_environment/dailbtu/):
#+BEGIN_SRC emacs-lisp
(defun TeX-delete-environment ()
  (interactive)
  (when (LaTeX-current-environment)
    (save-excursion
      (let* ((begin-start (save-excursion
                            (LaTeX-find-matching-begin)
                            (point)))
             (begin-end (save-excursion
                          (goto-char begin-start)
                          (search-forward-regexp "begin{.*?}")))
             (end-end (save-excursion
                        (LaTeX-find-matching-end)
                        (point)))
             (end-start (save-excursion
                          (goto-char end-end)
                          (1- (search-backward-regexp "\\end")))))
        ;; delete end first since if we delete begin first it shifts the
        ;; location of end
        (delete-region end-start end-end)
        (delete-region begin-start begin-end)))))
#+END_SRC

<tab> should always insert a tab (instead of indentation):
#+BEGIN_SRC emacs-lisp
	(add-hook 'LaTeX-mode-hook '(lambda () (setq-local tab-always-indent nil)))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
	:ensure t
	:config 
	(defun my-markdown-mode-config ()
		"settings for markdown mode"
		(interactive)
		(setq-default tab-width 4)
		(setq-default indent-tabs-mode t)
		(setq markdown-enable-math t))
	(add-hook 'markdown-mode 'my-markdown-mode-config)
	(setq markdown-enable-math t)
	)
#+END_SRC

** R

*** ess

=ess= (Emacs Speaks Statistics) is the package that integrates R into Emacs.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t
  :init (require 'ess-site))
#+END_SRC

** Deft

#+BEGIN_SRC emacs-lisp
(use-package deft												; for displaying list of note files
	:ensure t
  :bind
	("<f9> o" . deft)
	("<f9> d" . deft)
  :commands (deft)
  :config (setq deft-directory my-deft-dir
                deft-extensions '("md" "org")
								deft-recursive t
								deft-use-filename-as-title t
								deft-use-filter-string-for-filename t))
#+END_SRC

** Pomodoro technique

*** COMMENT tomatinho

Tomatinho brings the promodoro technique to Emacs. I prefer pomidor though.

#+BEGIN_SRC emacs-lisp
(use-package tomatinho
	:ensure t
	)
#+END_SRC

*** pomidor

Pomidor brings the promodoro technique to Emacs:
#+BEGIN_SRC emacs-lisp
(use-package pomidor
	:ensure t
	:init
	(setq pomidor-sound-tick nil
				pomidor-sound-tack nil
				pomidor-sound-overwork t)
	)
#+END_SRC

* Minor modes
** pandoc-mode

[[http://joostkremers.github.io/pandoc-mode/][pandoc-mode]] allows one to use =pandoc= from within Emacs. =pandoc= is a very rich transducer for text formats. Note that =pandoc= needs to be installed separately.

#+BEGIN_SRC emacs-lisp
(use-package pandoc-mode
	:ensure t
  :config
  ;; (add-hook 'markdown-mode-hook 'pandoc-mode)
  ;; (add-hook 'org-mode-hook 'pandoc-mode)
  (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings))
#+END_SRC

* Buffer

** General configuration

Automatically update buffers when files change:
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+end_src

Visible bell:
#+begin_src emacs-lisp
(setq visible-bell t)
(setq ring-bell-function (lambda ()
                           (invert-face 'mode-line)
                           (run-with-timer 0.05 nil 'invert-face 'mode-line)))
#+end_src

Delete marked text on typing:
#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

Use tabs for indent:
#+begin_src emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode t)
#+end_src

Scrolling:
#+begin_src emacs-lisp
(setq scroll-step            1
      scroll-conservatively  10000)
;; autoscroll compilation output
(setq compilation-scroll-output t)
;; scroll to the first/last line
(setq scroll-error-top-bottom t)
#+end_src

Show vertical line per indentation level: 
#+begin_src emacs-lisp
(use-package highlight-indent-guides
	:ensure t
	:config
	(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
	(setq highlight-indent-guides-method 'character)
	)
#+end_src

** Autocomplete

*** yasnippet (before auto-complete)

#+begin_src emacs-lisp
(use-package yasnippet
	:ensure t
	:config (yas-global-mode 1))
#+end_src

*** auto-complete
Sequence is important!

#+begin_src emacs-lisp
;; (require 'auto-complete)
;; (require 'auto-complete-auctex)
;; (require 'auto-complete-config)
;; (ac-config-default)
;; (setq ac-auto-show-menu t)
;; (setq ac-auto-show-menu 1)
;; (global-auto-complete-mode 1)
;; ;; (add-to-list 'ac-modes 'latex-mode)     ; activate auto-complete for latex <modes (AUCTeX or Emacs' builtin one).
;; (add-hook 'latex-mode-hook (function (lambda ()
;; 																					(ac-source-yasnippet))))
#+end_src

*** TODO company

- [ ] completion of LaTeX code in AUCTex
- [ ] completion in org-mode of LaTeX code

**** General settings

#+begin_src emacs-lisp
(use-package company
	:ensure t
	:config

	;; some general variables
	(setq company-idle-delay 0.2
				company-minimum-prefix-length 1
				company-selection-wrap-around t
				company-tooltip-flip-when-above t
				;; company-show-numbers t
				company-dabbrev-downcase nil
				company-auto-complete nil
				company-tooltip-align-annotations t
				company-transformers '(company-sort-by-occurrence))

	;; keys
	(eval-after-load 'company
	  '(progn
	     (define-key company-active-map (kbd "<tab>") 'company-complete-selection)
			 (define-key company-active-map (kbd "<return>") nil)
			 (define-key company-active-map (kbd "RET") nil)
	     ;; (define-key company-active-map (kbd "<tab>") 'company-complete-common)  ; Insert the common part of all candidates.  
	     ;; (define-key company-active-map (kbd "<tab>") 'company-select-next))
			 (define-key company-active-map (kbd "<up>") 'company-select-previous)
			 (define-key company-active-map (kbd "<down>") 'company-select-next)
			 ))
	
  ;; activate global-company-mode
	(add-hook 'after-init-hook 'global-company-mode)
	)
#+end_src

Add fuzzy matching capabilities:

#+begin_src emacs-lisp
(use-package company-flx
	:ensure t
	:config
	(with-eval-after-load 'company
		(company-flx-mode +1)))
#+end_src

When =company= is actively used by browsing completion candidates, =<return>= should execute the selected completion.

#+BEGIN_SRC emacs-lisp
;; Taken from https://github.com/company-mode/company-mode/issues/530.
(defun my-company-active-return ()
	(interactive)
	(if (company-explicit-action-p)
			(company-complete)
		(call-interactively
		 (or (key-binding (this-command-keys))
				 (key-binding (kbd "RET")))
		 )))

(define-key company-active-map (kbd "<return>") #'my-company-active-return)
(define-key company-active-map (kbd "RET") #'my-company-active-return)
#+END_SRC

**** Math symbols

#+BEGIN_SRC emacs-lisp
(use-package company-math
	:ensure t
	:config
	;; (add-to-list 'company-backends 'company-math-symbols-unicode) ; insert unicode symbol
	(add-to-list 'company-backends 'company-math-symbols-latex) ; insert LaTeX code
	)
#+END_SRC

**** LaTeX
  
  #+begin_src emacs-lisp
(use-package company-auctex
	:ensure t
	:config (company-auctex-init))
#+end_src

**** eshell

#+begin_src emacs-lisp
(add-hook 'eshell-mode-hook '(lambda () (setq company-idle-delay 0)))
#+end_src

**** org-mode

#+begin_src emacs-lisp
(add-to-list 'company-backends 'company-capf)
(defun add-pcomplete-to-capf ()
	(add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'add-pcomplete-to-capf)
#+end_src

Add easy templates to company (https://emacs.stackexchange.com/a/33487/12336):
#+BEGIN_SRC emacs-lisp
(defun org-easy-template--completion-table (str pred action)
  (pcase action
    (`nil (try-completion  str org-structure-template-alist pred))
    (`t   (all-completions str org-structure-template-alist pred))))

(defun org-easy-template--annotation-function (s)
  (format " -> %s" (cadr (assoc s org-structure-template-alist))))

(defun org-easy-template-completion-function ()
  (when (looking-back "^[ \t]*<\\([^ \t]*\\)" (point-at-bol))
    (list
     (match-beginning 1) (point)
     'org-easy-template--completion-table
     :annotation-function 'org-easy-template--annotation-function
     :exclusive 'no)))

(defun add-easy-templates-to-capf ()
	(add-hook 'completion-at-point-functions 'org-easy-template-completion-function nil t))
(add-hook 'org-mode-hook #'add-easy-templates-to-capf)

#+END_SRC

**** yasnippet

Execute when all backends added to =company-backends=.

#+begin_src emacs-lisp
(defvar company-mode/enable-yas t
	"Enable yasnippet for all backends.")
(defun company-mode/backend-with-yas (backend)
	(if (or (not company-mode/enable-yas)
					(and (listp backend) (member 'company-yasnippet backend)))
			backend
		(append (if (consp backend) backend (list backend))
						'(:with company-yasnippet))))
(setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))
  #+end_src

** Syntax checking

*** flycheck

#+begin_src emacs-lisp
(use-package flycheck
	:ensure t
	:config
	(global-flycheck-mode t)
	(add-hook 'text-mode-hook '(lambda ()(flycheck-mode 0)))
	)
#+end_src

*** flycheck-plantuml

#+BEGIN_SRC emacs-lisp
(use-package flycheck-plantuml
  :ensure t
  :after (flycheck plantuml)
  :config (flycheck-plantuml-setup))
#+END_SRC

** Spell checking

*** flyspell

#+begin_src emacs-lisp
(setq ispell-program-name "aspell")

;; remove keybindings for autocorrect 
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-;") nil))
(eval-after-load "flyspell"
	'(define-key flyspell-mode-map (kbd "C-.") nil))

;; ;; activate for text
;; (dolist (hook '(text-mode-hook LaTeX-mode-hook))
;; 	(add-hook hook (lambda () (flyspell-mode 1))))

(defun flyspell-toggle (arg)
	(interactive "p")
	(if (bound-and-true-p flyspell-mode)
			(progn
				 (flyspell-mode -1)
			)	 
		(progn
			(flyspell-buffer)
			(flyspell-mode)
			)))

;; move point to previous error
;; http://emacs.stackexchange.com/a/14912/2017
(defun flyspell-goto-previous-error (arg)
  "Go to arg previous spelling error."
  (interactive "p")
  (while (not (= 0 arg))
    (let ((pos (point))
          (min (point-min)))
      (if (and (eq (current-buffer) flyspell-old-buffer-error)
               (eq pos flyspell-old-pos-error))
          (progn
            (if (= flyspell-old-pos-error min)
                ;; goto beginning of buffer
                (progn
                  (message "Restarting from end of buffer")
                  (goto-char (point-max)))
              (backward-word 1))
            (setq pos (point))))
      ;; seek the next error
      (while (and (> pos min)
                  (let ((ovs (overlays-at pos))
                        (r '()))
                    (while (and (not r) (consp ovs))
                      (if (flyspell-overlay-p (car ovs))
                          (setq r t)
                        (setq ovs (cdr ovs))))
                    (not r)))
        (backward-word 1)
        (setq pos (point)))
      ;; save the current location for next invocation
      (setq arg (1- arg))
      (setq flyspell-old-pos-error pos)
      (setq flyspell-old-buffer-error (current-buffer))
      (goto-char pos)
      (if (= pos min)
          (progn
            (message "No more miss-spelled word!")
            (setq arg 0))))))


(defun flyspell-next-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-next-error)
		(ispell-word)
		)
  )

(defun flyspell-previous-and-ispell-word (args)
  ""
  (interactive "P")
	(progn
		(flyspell-goto-previous-error)
		(ispell-word)
		)
  )

#+end_src

*** flyspell-popup

#+BEGIN_SRC emacs-lisp
(use-package flyspell-popup
	:ensure t
	:defer t
	:init
	(progn
		(setq flyspell-popup-correct-delay 0.8)
		(add-hook 'flyspell-mode-hook 'flyspell-popup-auto-correct-mode))
	:config
	;; unset keys in popup-menu, so that flyspell-popup will close the popup when using them. 
	(define-key popup-menu-keymap (kbd "<right>") nil)
	(define-key popup-menu-keymap (kbd "<left>") nil)
	(define-key popup-menu-keymap (kbd "TAB") 'popup-select)
)

#+END_SRC

** Paren handling

*** smartparens

#+begin_src emacs-lisp
	(use-package smartparens
		:ensure t
		:config
		(use-package smartparens-config)
		(setq sp-autoescape-string-quote nil)
		(--each '(css-mode-hook
							js-mode-hook
							java-mode-hook
							perl-mode-hook
              plantuml-mode-hook
							python-mode-hook
							emacs-lisp-mode-hook
							LaTeX-mode-hook
							bibtex-mode-hook
							shell-mode-hook
							sh-mode-hook
							TeX-mode-hook
							markdown-mode-hook
							org-mode-hook)
			(add-hook it #'smartparens-mode))
		(require 'smartparens-latex)
		;; org-mode
		(sp-with-modes 'org-mode
			(sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-before-word-p sp-point-at-bol-p sp-in-math-p) )
			(sp-local-pair "_" "_" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "/" "/" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "~" "~" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "=" "=" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p) )
			(sp-local-pair "+" "+" :unless '(sp-point-after-word-p sp-point-before-word-p sp-in-math-p tl/sp-point-after-hash-p) )
			(sp-local-pair "$" "$" :unless '(sp-point-after-word-p sp-point-before-word-p) )
			(sp-local-pair "«" "»"))
		)
	(defun tl/sp-point-after-hash-p (id action context)
		"Return t if point is after a hash, nil otherwise.
	This predicate is only tested on \"insert\" action.
	Its definition follows the one of sp-point-after-word-p."
		(when (eq action 'insert)
			(sp--looking-back-p (concat "\\(#\\)" (regexp-quote id)))))

	;; jump to matching paren
	(defun goto-match-paren (arg)
		"Go to the matching  if on (){}[], similar to vi style of % "
		(interactive "p")
		;; first, check for "outside of bracket" positions expected by forward-sexp, etc.
		(cond ((looking-at "[\[\(\{]") (forward-sexp))
					((looking-back "[\]\)\}]" 1) (backward-sexp))
					;; now, try to succeed from inside of a bracket
					((looking-at "[\]\)\}]") (forward-char) (backward-sexp))
					((looking-back "[\[\(\{]" 1) (backward-char) (forward-sexp))
					(t nil)))
	(global-set-key (kbd "C-M-m") 'goto-match-paren)
	(global-set-key (kbd "M-(") 'sp-backward-sexp)
	(global-set-key (kbd "M-)") 'sp-forward-sexp)
	(global-set-key (kbd "M-m") 'goto-match-paren)
	(global-set-key (kbd "M-[") 'sp-beginning-of-sexp)
	(global-set-key (kbd "M-]") 'sp-end-of-sexp)
	(global-set-key (kbd "M-DEL") nil)
	(global-set-key (kbd "M-DEL M-[") 'sp-unwrap-sexp)
#+end_src

*** emacs-pairs

#+begin_src emacs-lisp
;; https://ebzzry.github.io/emacs-pairs.html
;; (defmacro def-pairs (pairs)
;;   `(progn
;;      ,@(loop for (key . val) in pairs
;;           collect
;;             `(defun ,(read (concat
;;                             "wrap-with-"
;;                             (prin1-to-string key)
;;                             "s"))
;;                  (&optional arg)
;;                (interactive "p")
;;                (sp-wrap-with-pair ,val)))))
;; (def-pairs ((paren        . "(")
;;             (bracket      . "[")
;;             (brace        . "{")
;;             (single-quote . "'")
;;             (double-quote . "\"")
;;             (back-quote   . "`")))
;; (global-set-key (kbd "C-[") 'wrap-with-brackets) ; TODO: find nice key bindings
;; (global-set-key (kbd "C-(") 'wrap-with-parens)
;; (global-set-key (kbd "C-{") 'wrap-with-braces)
#+end_src

** Indentation

Auto-indent when yanking
https://www.emacswiki.org/emacs/AutoIndentation

#+begin_src emacs-lisp
(dolist (command '(yank yank-pop))
	(eval `(defadvice ,command (after indent-region activate)
					 (and (not current-prefix-arg)
								(member major-mode '(emacs-lisp-mode lisp-mode
																										 clojure-mode    scheme-mode
																										 haskell-mode    ruby-mode
																										 rspec-mode      python-mode
																										 c-mode          c++-mode
																										 objc-mode       latex-mode
																										 plain-tex-mode))
								(let ((mark-even-if-inactive transient-mark-mode))
									(indent-region (region-beginning) (region-end) nil))))))
#+end_src

Shift/delete indentation at cursor position or region:
#+BEGIN_SRC emacs-lisp
;; shift-region is taken from http://stackoverflow.com/a/6918574/6452961
(defun shift-region (distance)
	"Shift the selected region right if distance is positive, left if negative"
  (let ((mark (mark)))
    (save-excursion
      (indent-rigidly (region-beginning) (region-end) distance)
      (push-mark mark t t)
      ;; Tell the command loop not to deactivate the mark
      ;; for transient mark mode
      (setq deactivate-mark nil))))

(defun tl/delete-indentation ()
  (interactive)
  (if (use-region-p)
			(shift-region -999)
		(indent-rigidly (line-beginning-position) (line-end-position) -999)
		))
#+END_SRC

** Selection

*** expand-region

#+begin_src emacs-lisp
(use-package expand-region
	:ensure t
	:bind ("C-+" . er/expand-region)
	)
#+end_src

*** Mouse selection

Copy mouse selection to kill-ring:
#+begin_src emacs-lisp
;; (setq mouse-drag-copy-region t)
#+end_src

** Context menu

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<mouse-3>") 'mouse-major-mode-menu)
(global-set-key (kbd "<C-down-mouse-3>") 'mouse-popup-menubar)
#+END_SRC

Org-mode has its own context menu:
#+BEGIN_SRC emacs-lisp
(require 'org-mouse)
#+END_SRC

*** COMMENT ctxmenu

Unfortunately, =ctxmenu= lets my Emacs crash.

#+BEGIN_SRC emacs-lisp
(use-package ctxmenu
	:ensure t
	:config
	(require 'ctxmenu-config)
	(ctxmenu-config:setup ctxmenu-config:extra-features)
	;; (setq ctxmenu-config:exclude-features '(window register))
	(define-key global-map [mouse-3] 'ctxmenu:show)
	)
#+END_SRC

*** discover

Maybe an option in the future. 

https://github.com/mickeynp/discover.el

** Cursor actions

*** ace-jump

#+begin_src emacs-lisp
(use-package ace-jump-mode
	:ensure t
	:bind 
	("C-c SPC" . ace-jump-mode))
#+end_src

*** TODO dump-jump

- [ ] adjust key bindings
- [ ] add LaTeX support

Jump to definition without using tags.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config (setq dumb-jump-selector 'helm)
)
#+END_SRC

*** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
	:ensure t
	:bind
	("C-S-c C-S-c" . mc/edit-lines)
	("C->" . mc/mark-next-like-this)
	("C-<" . mc/mark-previous-like-this)
	("C-c C-<" . mc/mark-all-like-this)
	)
#+end_src

*** point-undo

Cursor position history (LOCAL)

#+begin_src emacs-lisp
(require 'point-undo)
(global-set-key [M-left] 'point-undo)
(global-set-key [M-right] 'point-redo)
(global-set-key (kbd "M-j") 'point-undo)
(global-set-key (kbd "M-k") 'point-redo)
;; focus on line-based jumps
;; http://emacs.stackexchange.com/a/28078/12336
(defvar point-undo-ring-length 100)
(defvar point-undo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-undo-ring)
(defvar point-redo-ring (make-ring point-undo-ring-length))
(make-variable-buffer-local 'point-redo-ring)
(defun point-undo-pre-command-hook ()
  "Save positions before command."
  (unless (or (eq this-command 'point-undo)
              (eq this-command 'point-redo))
    (let ((line (line-number-at-pos)))
      (when (eq line (cdr (nth 0 (ring-elements point-undo-ring))))
        (ring-remove point-undo-ring 0))
      (ring-insert point-undo-ring (cons (point) line))
      (setq point-redo-ring (make-ring point-undo-ring-length)))))
(add-hook 'pre-command-hook 'point-undo-pre-command-hook)
(defun point-undo-doit (ring1 ring2)
  "ring1, ring2 = {point-undo-ring, point-redo-ring}"
  (condition-case nil
      (progn
        (goto-char (car (nth 0 (ring-elements ring1)))) 
        (ring-insert ring2 (ring-remove ring1 0)))
    (error nil)))
(defun point-undo ()
  "Undo position."
  (interactive)
  (point-undo-doit point-undo-ring point-redo-ring))
(defun point-redo ()
  "Redo position."
  (interactive)
  (when (or (eq last-command 'point-undo)
            (eq last-command 'point-redo))
    (point-undo-doit point-redo-ring point-undo-ring)))
#+end_src

*** goto-last-change

Cursor position undo history:

#+begin_src emacs-lisp
(use-package goto-last-change
	:ensure t
	:bind
	("M-_" . goto-last-change))
#+end_src

*** smarter C-a and C-e

Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp
(defun my/smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my/smarter-move-beginning-of-line)
#+END_SRC

** Images

#+BEGIN_SRC emacs-lisp
(use-package image+
	:ensure t
	:init
	(eval-after-load 'image '(require 'image+))
	:config
	(setq imagex-convert-command "magick")  ; "convert" does not work on Windows machines 
	)
#+END_SRC

** Undo & remove

*** undo-tree

Visualize the undo history.

#+begin_src emacs-lisp
(use-package undo-tree
	:ensure t
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+end_src

*** Remove newlines

- alternative: [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]]

http://stackoverflow.com/a/5194503
#+begin_src emacs-lisp
(defun remove-newlines-in-region ()
  "Removes all newlines in the region."
  (interactive)
  (save-restriction
    (narrow-to-region (point) (mark))
    (goto-char (point-min))
    (while (search-forward "\n" nil t) (replace-match " " nil t))))

(defun remove-newline ()
	(save-excursion 
		(search-forward "\n")
		(replace-match " ")))

(defun remove-newlines-or-blank-lines-dwim ()
	(interactive)
	(progn (if (use-region-p)
						 (remove-newlines-in-region)
					 (if (this-line-empty-p)
							 (delete-blank-lines)
						 (remove-newline)
					 ))))

(defun next-line-empty-p ()
  (save-excursion
		(next-line)
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun this-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))
#+end_src

*** Remove extra spaces

- alternative: [[https://github.com/jcpetkovich/shrink-whitespace.el][shrink-whitespace]]

Remove extra spaces from line or region (TODO):
#+begin_src emacs-lisp
(defun tl/remove-extra-spaces-dwim ()
	"Remove extra spaces in line or in region."
	(interactive)
	(if (region-active-p)
			(save-restriction
				(narrow-to-region (point) (mark))
				(save-excursion 
					(goto-char (point-min))
					(while (re-search-forward "[ ]+" nil t) (replace-match " " nil t))))
		(save-excursion
			(move-beginning-of-line nil)  					; FIXME: undo doesn't see save-excursion
			(while (re-search-forward "[ ]+" (line-end-position) t)
				(replace-match " "))))
	)
#+end_src

*** Tracking changes

http://emacs-fu.blogspot.de/2009/05/tracking-changes.html
#+begin_src emacs-lisp
;; higlight changes in documents
(global-highlight-changes-mode t)
(setq highlight-changes-visibility-initial-state nil); initially hide
;; toggle visibility
;; (global-set-key (kbd "<f8>") 'highlight-changes-visible-mode) ;; changes
;; remove the change-highlight in region
;; (global-set-key (kbd "S-<f8>") 'highlight-changes-remove-highlight)
;; if you're not already using it for something else...
(global-set-key (kbd "<M-prior>") 'highlight-changes-next-change)
(global-set-key (kbd "<M-next>")  'highlight-changes-previous-change)
;; faces
(set-face-foreground 'highlight-changes nil)
(set-face-background 'highlight-changes "#916868")
(set-face-foreground 'highlight-changes-delete nil)
(set-face-background 'highlight-changes-delete "#916868")

;; http://stackoverflow.com/a/21084181/6452961
;; show mark in fringe
(eval-after-load "hilit-chg"
	'(progn
		 (defvar highlight-fringe-mark 'filled-square
			 "The fringe bitmap name marked at changed line.
	Should be selected from `fringe-bitmaps'.")

		 (defadvice hilit-chg-make-ov (after hilit-chg-add-fringe activate)
			 (mapc (lambda (ov)
							 (if (overlay-get ov 'hilit-chg)
									 (let ((fringe-anchor (make-string 1 ?x)))
										 (put-text-property 0 1 'display
																				(list 'left-fringe highlight-fringe-mark)
																				fringe-anchor)
										 (overlay-put ov 'before-string fringe-anchor))
								 ))
						 (overlays-at (ad-get-arg 1))))))
;; remove highlights on save time
(add-hook 'after-save-hook
					(lambda ()
						(when highlight-changes-mode
							(save-restriction
								(widen)
								(highlight-changes-remove-highlight (point-min) (point-max))))))
#+end_src

** Switch between buffers

Switching between buffers with C-tab:
#+begin_src emacs-lisp
  (use-package iflipb
    :ensure t
    :config
    (setq iflipb-wrap-around t)
    (setq iflipb-ignore-buffers "^ ")     ; include all buffers
    :bind
    ("<C-tab>" . iflipb-next-buffer))
#+end_src

** Narrowing

http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+begin_src emacs-lisp
(defun narrow-or-widen-dwim (p)
"Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
(interactive "P")
(declare (interactive-only))
(cond ((and (buffer-narrowed-p) (not p)) (widen))
			((region-active-p)
			 (narrow-to-region (region-beginning)
												 (region-end)))
			((derived-mode-p 'org-mode)
			 ;; `org-edit-src-code' is not a real narrowing
			 ;; command. Remove this first conditional if
			 ;; you don't want it.
			 (cond ((ignore-errors (org-edit-src-code) t)
							(delete-other-windows))
						 ((ignore-errors (org-narrow-to-block) t))
						 (t (org-narrow-to-subtree))))
			((derived-mode-p 'latex-mode)
			 (LaTeX-narrow-to-environment))
			(t (narrow-to-defun))))

;; This line actually replaces Emacs' entire narrowing
;; keymap, that's how much I like this command. Only
;; copy it if that's what you want.
(define-key ctl-x-map "n" #'narrow-or-widen-dwim)
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (define-key LaTeX-mode-map "\C-xn"
              nil)))
#+end_src

** File browser
*** ranger, deer

Use deer instead plain directory listing:
#+begin_src emacs-lisp
(use-package ranger
	:ensure t
	:bind
	("C-x C-d" . deer))

;; open file from inside a buffer
(global-set-key (kbd "C-x f") 'find-file-at-point)
#+end_src

** Commenting

#+begin_src emacs-lisp
(global-set-key (kbd "C-;") 'comment-or-uncomment-region-or-line)
(eval-after-load "LaTeX-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(eval-after-load "markdown-mode"
	'(define-key LaTeX-mode-map (kbd "C-;") 'comment-or-uncomment-region-or-line))
(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
				(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)
    (next-line)))
#+end_src

*** Critical markup

#+begin_src emacs-lisp
(use-package cm-mode
	:ensure t
	:config
	(setq-default cm-author user-acronym))
#+end_src

** Line actions
*** Delete line
#+begin_src emacs-lisp
;; (global-set-key (kbd "C-d C-o") 'delete-blank-lines) ; not allowed here, see underi-mode.el
;; (global-set-key (kbd "C-d C-m") 'delete-blank-lines)
(global-set-key (kbd "C-S-k") 'kill-whole-line)
;; (global-set-key (kbd "C-k") 'kill-sentence) ; too greedy
(global-set-key (kbd "C-S-d") 'kill-whole-line)
#+end_src

Copy/cut whole line or region:
#+begin_src emacs-lisp
(global-set-key (kbd "C-w") 'xah-cut-line-or-region) ; cut
(global-set-key (kbd "M-w") 'xah-copy-line-or-region) ; copy
(defun xah-cut-line-or-region ()
  "Cut current line, or text selection.
When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2015-06-10"
  (interactive)
  (if current-prefix-arg
      (progn ; not using kill-region because we don't want to include previous kill
        (kill-new (buffer-string))
        (delete-region (point-min) (point-max)))
    (progn (if (use-region-p)
               (kill-region (region-beginning) (region-end) t)
             (kill-region (line-beginning-position) (line-beginning-position 2))))))
(defun xah-copy-line-or-region ()
  "Copy current line, or text selection.
When called repeatedly, append copy subsequent lines.
When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').
URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
Version 2016-06-18"
  (interactive)
  (let (-p1 -p2)
    (if current-prefix-arg
        (setq -p1 (point-min) -p2 (point-max))
      (if (use-region-p)
          (setq -p1 (region-beginning) -p2 (region-end))
        (setq -p1 (line-beginning-position) -p2 (line-end-position))))
    (if (eq last-command this-command)
        (progn
          (progn ; hack. exit if there's no more next line
            (end-of-line)
            (forward-char)
            (backward-char))
          ;; (push-mark (point) "NOMSG" "ACTIVATE")
          (kill-append "\n" nil)
          (kill-append (buffer-substring-no-properties (line-beginning-position) (line-end-position)) nil)
          (message "Line copy appended"))
      (progn
        (kill-ring-save -p1 -p2)
        (if current-prefix-arg
            (message "Buffer text copied")
          (message "Text copied"))))
		;; TL: commented out the following two lines. Cursor remains at region.
    ;; (end-of-line)   
    ;; (forward-char)
    ))
#+end_src

*** New line

#+begin_src emacs-lisp
(global-set-key (kbd "S-<return>") 'smart-open-line)
(global-set-key (kbd "C-x C-<return>") 'smart-open-line)
(global-set-key (kbd "C-S-<return>") 'smart-open-line-above)
(global-set-key (kbd "C-o") 'smart-open-line)
(global-set-key (kbd "C-S-o") 'smart-open-line-above)
;; http://emacsredux.com/blog/2013/03/26/smarter-open-line/
(defun smart-open-line ()
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
;; http://emacsredux.com/blog/2013/06/15/open-line-above/
(defun smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
#+end_src

*** Center line
#+begin_src emacs-lisp
(global-set-key (kbd "C-S-l") 'recenter-top-bottom)
#+end_src

** Capitalization

Toggle letter case:
 #+begin_src emacs-lisp
(global-set-key (kbd "C-9") 'xah-toggle-letter-case) 
(defun xah-toggle-letter-case ()
  "Toggle the letter case of current word or text selection.
Always cycle in this order: Init Caps, ALL CAPS, all lower.

URL `http://ergoemacs.org/emacs/modernization_upcase-word.html'
Version 2016-01-08"
  (interactive)
  (let (
        (deactivate-mark nil)
        -p1 -p2)
    (if (use-region-p)
        (setq -p1 (region-beginning)
              -p2 (region-end))
      (save-excursion
        (skip-chars-backward "[:alnum:]")
        (setq -p1 (point))
        (skip-chars-forward "[:alnum:]")
        (setq -p2 (point))))
    (when (not (eq last-command this-command))
      (put this-command 'state 0))
    (cond
     ((equal 0 (get this-command 'state))
      (upcase-initials-region -p1 -p2)
      (put this-command 'state 1))
     ((equal 1  (get this-command 'state))
      (upcase-region -p1 -p2)
      (put this-command 'state 2))
     ((equal 2 (get this-command 'state))
      (downcase-region -p1 -p2)
      (put this-command 'state 0)))))
#+end_src

** Buffer actions

Open untitled new buffer:
#+begin_src emacs-lisp
(defun xah-new-empty-buffer ()
  "Open a new empty buffer.
URL `http://ergoemacs.org/emacs/emacs_new_empty_buffer.html'
Version 2015-06-12"
  (interactive)
  (let ((buf (generate-new-buffer "untitled")))
    (switch-to-buffer buf)
    (funcall (and initial-major-mode))
    (setq buffer-offer-save t)))
(global-set-key (kbd "<f7> <f7>") 'xah-new-empty-buffer)
#+end_src

Kill buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "M-<f4>") 'kill-this-buffer)
 #+end_src
 
Revert buffer:
 #+begin_src emacs-lisp
(global-set-key (kbd "<f5>") 'revert-buffer)
 #+END_SRC

** Charmap

For showing the character map and letting one select a special symbol:

#+BEGIN_SRC emacs-lisp
(use-package charmap
	:ensure t)
#+END_SRC

** Thesauri
*** synosaurus

Thesaurus fontend for Emacs with pluggable backends:
- OpenThesaurus for German (online)
- WordNet for English (http://wordnet.princeton.edu/wordnet/download/current-version)

#+BEGIN_SRC emacs-lisp
(use-package synosaurus
	:ensure t
	:config
	(setq-default synosaurus-choose-method "default"
								synosaurus-backend 'synosaurus-backend-openthesaurus)
	)
#+END_SRC

* Project management

** projectile

Project management based on Git repositories.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :commands (projectile-find-file 
						 projectile-switch-project) 
  :diminish projectile-mode
  :config
	(setq projectile-remember-window-configs t
				projectile-enable-caching t			  ; speed up projectile by caching index
				projectile-indexing-method 'alien ; use external commands like find, git etc. Maybe not supported in Windows.
				projectile-require-project-root t ; only use projectile in git projects
				projectile-keymap-prefix (kbd "C-x p") ; change keymap prefix
				projectile-switch-project-action 'projectile-dired ; use dired when switching projects
				)
  (projectile-global-mode))
#+END_SRC

Use helm for completions.

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
	:ensure t
	:bind (("C-x p o" . helm-projectile-find-file)
				 ("C-x p p" . helm-projectile-switch-project)
				 ("C-x p h" . helm-projectile)
				 ("C-x p g" . helm-projectile-grep)
				 ("C-x p s" . helm-projectile-grep))
	)
#+END_SRC

* underi-mode

Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 

Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html

#+BEGIN_SRC emacs-lisp
	(define-minor-mode underi-mode
		"Key bindings for more ergonomic cursor movement: the cursor movement keys are under the <i> key and get activated with the Meta/Alt key. 
	Inspired by: http://ergoemacs.org/emacs/emacs_useful_user_keybinding.html"
		:lighter " ui"
		;; :global "t"
		:init-value t
		:keymap (let ((map (make-keymap)))

							(define-key input-decode-map "\C-i" [#x4000069])  ; to disentangle <tab> and C-i
							(define-key input-decode-map (kbd "C-i") (kbd "H-i"))

							;; cursor keys
							(define-key key-translation-map (kbd "M-i") (kbd "<up>"))
							(define-key key-translation-map (kbd "M-k") (kbd "<down>"))
							(define-key key-translation-map (kbd "M-j") (kbd "<left>"))		
							(define-key key-translation-map (kbd "M-l") (kbd "<right>"))
							(define-key key-translation-map (kbd "M-I") (kbd "S-<up>"))
							(define-key key-translation-map (kbd "M-K") (kbd "S-<down>"))
							(define-key key-translation-map (kbd "M-J") (kbd "S-<left>"))		
							(define-key key-translation-map (kbd "M-L") (kbd "S-<right>"))

							;; more cursor keys
							(define-key map (kbd "M-n") 'scroll-up-command)
							(define-key map (kbd "M-p") 'scroll-down-command)
							(define-key map (kbd "M-o") 'point-redo)
							(define-key map (kbd "M-u") 'point-undo)
							(define-key map (kbd "M-z") 'goto-last-change)
							(define-key map (kbd "C-M-i") 'backward-paragraph)
							(define-key map (kbd "C-M-k") 'forward-paragraph)
							(define-key map (kbd "C-M-j") 'left-word)
							(define-key map (kbd "C-M-l") 'right-word)

							(define-key map (kbd "M-s-j")  'windmove-left)
							(define-key map (kbd "M-s-l") 'windmove-right)
							(define-key map (kbd "M-s-i")   'windmove-up)
							(define-key map (kbd "M-s-k")  'windmove-down)

							;; ;; Why would this be necessary?
							;; (define-key key-translation-map (kbd "C-n") (kbd "C-c C-n"))
							;; (define-key key-translation-map (kbd "C-p") (kbd "C-c C-p"))

							;; delete 
							(define-key map (kbd "C-d") nil)
							(define-key map (kbd "C-d C-k") 'kill-line)
							(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d <left>") 'delete-backward-char)
							(define-key map (kbd "C-d <right>") 'delete-forward-char)
							(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
							(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
							(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
							(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
							(define-key map (kbd "C-d C-o") 'delete-blank-lines)
							(define-key map (kbd "C-d C-m") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-<return>") 'remove-newlines-or-blank-lines-dwim)
							(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
							(define-key map (kbd "C-d C-e") 'kill-line)
							(define-key map (kbd "C-S-d") 'kill-whole-line)
							(define-key map (kbd "C-d SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d C-SPC") 'tl/remove-extra-spaces-dwim)
							(define-key map (kbd "C-d TAB") 'tl/delete-indentation)
							(define-key map (kbd "C-d C-TAB") 'tl/delete-indentation)
							(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
							(define-key map (kbd "C-d )") 'sp-unwrap-sexp)

							(define-key LaTeX-mode-map (kbd "C-d m") 'TeX-delete-macro)
							(define-key LaTeX-mode-map (kbd "C-d e") 'TeX-delete-environment)
							(define-key LaTeX-mode-map (kbd "C-d t") 'TeX-clean)

							;; return
							(define-key input-decode-map (kbd "C-m") (kbd "H-o")) ; to disentangle <return> and C-m
							(define-key key-translation-map (kbd "H-o") (kbd "RET"))
							(define-key map (kbd "C-S-m") 'smart-open-line)

 							;; org-babel
							(define-key org-mode-map (kbd "C-d r") 'org-babel-remove-result)

							;; miscellaneous actions
							(define-key map (kbd "C-j") 'ace-jump-mode)
							(define-key map (kbd "H-i") 'helm-imenu)
							(define-key map (kbd "C-S-i") 'imenu-list)

							map
							)
		(add-hook 'minibuffer-setup-hook 'underi-minibuffer)
		(with-eval-after-load 'org
			(define-key org-mode-map (kbd "C-d c") 'org-table-delete-column )
			(define-key org-mode-map (kbd "C-d C-c") 'org-table-delete-column )
			)																	

	)	
	;; TODO: make C-d switch to delete-mode?
	;; http://stackoverflow.com/a/12010437/6452961

	(defun tl/kill-forward-line (N)
		(interactive)
		(save-excursion
			(when (= (forward-line N) 0)
				(kill-whole-line))))

	(defun underi-minibuffer ()
		"Keymap for the minibuffer."
		(let ((map minibuffer-local-map))

			;; move cursor
			(define-key map (kbd "M-n") 'scroll-up-command)
			(define-key map (kbd "M-p") 'scroll-down-command)
			(define-key map (kbd "M-o") 'point-redo)
			(define-key map (kbd "M-u") 'point-undo)
			(define-key map (kbd "M-z") 'goto-last-change)
			(define-key map (kbd "C-M-i") 'backward-paragraph)
			(define-key map (kbd "C-M-k") 'forward-paragraph)
			(define-key map (kbd "C-M-j") 'left-word)
			(define-key map (kbd "C-M-l") 'right-word)

			;; delete 
			(define-key map (kbd "C-d") nil)
			(define-key map (kbd "C-d C-k") 'kill-line)
			(define-key map (kbd "C-d <up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d <left>") 'delete-backward-char)
			(define-key map (kbd "C-d <right>") 'delete-forward-char)
			(define-key map (kbd "C-d <down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-<up>") '(lambda () (interactive) (tl/kill-forward-line -1)))
			(define-key map (kbd "C-d C-<left>") 'delete-backward-char)
			(define-key map (kbd "C-d C-<right>") 'delete-forward-char)
			(define-key map (kbd "C-d C-<down>") '(lambda () (interactive) (tl/kill-forward-line 1)))
			(define-key map (kbd "C-d C-a") '(lambda () (interactive) (kill-line 0)))
			(define-key map (kbd "C-S-d") 'kill-whole-line)
			(define-key map (kbd "C-d [") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d ]") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d {") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d }") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d (") 'sp-unwrap-sexp)
			(define-key map (kbd "C-d )") 'sp-unwrap-sexp)
			))

	(define-key helm-map (kbd "H-i") 'helm-select-action) ; show actions (default is <tab>)

	;; (add-hook 'text-mode-hook 'underi-mode) ; superseded by :init-value t
	;; (add-hook 'prog-mode-hook 'underi-mode) ; superseded by :init-value t
#+END_SRC

* winkeys-mode

Key bindings roughly following the conventions of the Windows habitat.

#+BEGIN_SRC emacs-lisp
(define-minor-mode winkeys-mode
	"Key bindings roughly following the conventions of the Windows habitat."
	:init-value t
	:global t
	:lighter " wk"
	:keymap (let ((map (make-keymap)))
						
						;; save
						(define-key map (kbd "C-s") 'save-buffer)
						(define-key map (kbd "C-S-s") 'write-file)

						;; search and replace
						(define-key map (kbd "C-f") 'helm-swoop)
						(define-key map (kbd "C-S-f a") 'helm-multi-swoop-all)
						(define-key map (kbd "C-S-f m") 'helm-multi-swoop-current-mode)
						(define-key map (kbd "C-S-f s") 'isearch-forward)
						(define-key map (kbd "C-S-f C-s") 'isearch-forward)
						(define-key map (kbd "C-S-f r") 'isearch-backward)
						(define-key map (kbd "C-S-f C-r") 'isearch-backward)
						;; (define-key map (kbd "C-f") 'isearch-search)
						(define-key map (kbd "C-r") 'query-replace)
						(define-key map (kbd "C-S-r") 'query-replace-regexp)
						(define-key map (kbd "C-o") 'helm-find-files)

						;; mark all
						(define-key map (kbd "C-x C-a") 'mark-whole-buffer)
						
						;; quit
						(define-key key-translation-map (kbd "M-q") (kbd "C-g"))

						;; undo/redo
						(define-key map (kbd "C-z") 'undo-tree-undo)
						(define-key map (kbd "C-S-z") 'undo-tree-redo)

						;; yank
						(define-key map (kbd "C-v") 'yank)						

						;; press ESC only once
						(define-key map (kbd "<escape>") 'keyboard-escape-quit)
						
						map
						)

	;; body 

	(add-hook 'minibuffer-setup-hook 'winkeys-minibuffer)

	(with-eval-after-load 'helm-swoop
		(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
		(define-key helm-swoop-map (kbd "C-f") 'tl/helm-swoop-C-s) 
		(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
		(define-key helm-multi-swoop-map (kbd "C-f") 'helm-next-line)
		(define-key helm-swoop-map (kbd "C-S-f a") 'helm-multi-swoop-all-from-helm-swoop)
		(define-key helm-swoop-map (kbd "C-S-f m") 'helm-multi-swoop-current-mode-from-helm-swoop)
		(define-key helm-swoop-map (kbd "M-a") 'helm-multi-swoop-all-from-helm-swoop))

	(with-eval-after-load 'company
		(define-key company-active-map (kbd "C-s") 'save-buffer))

	;; ;; Maybe this is not needed any more 	
	;; (add-hook 'org-src-mode-hook
	;; 					(lambda ()((define-key (kbd "C-s") 'org-edit-src-save))))

;; (define-key key-translation-map (kbd "C-v") (kbd "C-y")) ; unfortunately this interferes with key chords using C-v
	)

(winkeys-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun winkeys-minibuffer ()
	"Keymap for the minibuffer."
	(let ((map minibuffer-local-map))

		;; undo/redo
		(define-key map (kbd "C-z") 'undo-tree-undo)
		(define-key map (kbd "C-S-z") 'undo-tree-redo)
		
		))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp
	;; Let helm-swoop behave more like isearch
	;; FIXME: does not follow search hits; helm-action-follow-forward does not work here
	(defun tl/helm-swoop-C-s ()
		(interactive)
		(if (boundp 'helm-swoop-pattern)
				(if (equal helm-swoop-pattern "")
						(previous-history-element 1)
					(helm-next-line))
			(helm-next-line)
			))
#+END_SRC

* TODO winkeys-starter-mode

https://github.com/publicus/emacs-org-mode-for-the-laity

* COMMENT sr-speedbar

#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
	:ensure t
	:bind
	("C-c C-k C-b" . sr-speedbar-toggle)
	:config
	(setq sr-speedbar-right-side nil)                          ; always on left side
	(add-hook 'speedbar-mode-hook '(lambda () (linum-mode 0))) ; disable linum for speedbar
	(setq speedbar-show-unknown-files t)                       ; show all files
	(setq sr-speedbar-width 30)                                ; default width
	)
#+END_SRC

* Windows and frames

Better keys for closing and switching between windows. The rest is done in [[*hydra-f2][hydra-f2]].

#+BEGIN_SRC emacs-lisp
	(global-set-key (kbd "M-s-<left>")  'windmove-left)
	(global-set-key (kbd "M-s-<right>") 'windmove-right)
	(global-set-key (kbd "M-s-<up>")   'windmove-up)
	(global-set-key (kbd "M-s-<down>")  'windmove-down)

	;; close window
	(global-set-key (kbd "M-<f2>") 'delete-window)
#+END_SRC


=winner-mode= allows you to undo (and redo) changes in the window configuration.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** COMMENT golden-ratio

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :ensure t
  :diminish golden-ratio-mode
  :init
  (golden-ratio-mode 1))
#+END_SRC

** transpose-frame

#+BEGIN_SRC emacs-lisp
(use-package transpose-frame
  :ensure t
  ;; :bind ("H-t" . transpose-frame)
)
#+END_SRC

* Bookmarks

#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat user-emacs-directory "bookmarks")) ; default bookmark file
(setq bookmark-save-flag 1) ; everytime bookmark is changed, automatically save it
(global-set-key (kbd "C-x C-r") 'helm-bookmarks)
#+END_SRC

* Git

** magit

#+BEGIN_SRC emacs-lisp
(use-package magit
	:ensure t
	:bind
	("C-x g" . magit-status)
	;; ("C-x C-g" . magit-status)
	:config
	;; show magit full screen
	(setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
	)
#+end_src

** TODO COMMENT magithub

- [ ] Has to be properly configured.

Enhancement of magit to make available a more comprehensive access to Github repositories, regrading issues etc.:

#+BEGIN_SRC emacs-lisp
(use-package magithub
	:ensure t
  :after magit
  :config (magithub-feature-autoinject t))
#+END_SRC

** git-gutter

#+begin_src emacs-lisp
(use-package git-gutter
	:ensure t
	:config
	(global-git-gutter-mode +1)
	;; (git-gutter:linum-setup) ; git-gutter is struggling with linum-mode
	(custom-set-variables
	 '(git-gutter:update-interval 2))
	:bind
	("C-x C-g" . nil)
	("C-x C-g TAB" . git-gutter:popup-hunk)
	("C-x C-g _" . git-gutter:revert-hunk)
	("C-x C-g z" . git-gutter:revert-hunk)
	("C-x C-g C-g" . git-gutter-mode)
	("C-x C-g g" . git-gutter-mode)
	("C-x C-g n" . git-gutter:next-hunk)
	("C-x C-g p" . git-gutter:previous-hunk)
	)
#+END_SRC

* Shells

** better-shell

#+BEGIN_SRC emacs-lisp
(use-package better-shell
    :ensure t
    ;; :bind (("C-'" . better-shell-shell)
    ;;        ("C-;" . better-shell-remote-open))
		)
#+END_SRC

** Windows powershell

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'windows-nt)
		(use-package powershell
			:ensure t)
)
(put 'upcase-region 'disabled nil)
#+END_SRC

** eshell

#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
					'(lambda () (define-key eshell-mode-map (kbd "<tab>") 'completion-at-point)))
(setq eshell-cmpl-dir-ignore "\`\\(CVS\\)/\\'") ; in order to complete `..` to `../`
(defun tl/eshell ()										; http://emacs.stackexchange.com/a/28603/12336
  (interactive)
  (eshell t))
(global-set-key (kbd "<f7> e") 'tl/eshell)
 #+END_SRC

* Process monitor

** proced

The built-in top-like process viewer in Emacs.

See https://www.masteringemacs.org/article/displaying-interacting-processes-proced or http://emacsredux.com/blog/2013/05/02/manage-processes-with-proced/

#+BEGIN_SRC emacs-lisp
(require 'proced)
(setq proced-auto-update-interval 1)

(defun proced-settings ()
  (proced-toggle-auto-update))
(add-hook 'proced-mode-hook 'proced-settings)

(global-set-key (kbd "C-x P") 'proced)
#+END_SRC

* Tags

** etags

=etags= is part of Emacs.

** TODO COMMENT GLOBAL

- [X] install =mkid= (from =idutils=) >= v4.5)
- [ ] Still it does not work for ever language, e.g. elisp and latex.
  
[[http://savannah.gnu.org/projects/global/][GNU GLOBAL]] is a source code tagging system.

#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :diminish ggtags-mode
  ;; :bind (("M-m T"   . ggtags-find-tag-regexp)
  ;;         ("M-m g t" . ggtags-create-tags)
  ;;         ("M-m g T" . ggtags-update-tags))
  ;; :init
  ;; (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
  :config
  (add-hook 'prog-mode-hook 'ggtags-mode))
#+END_SRC

* Chat

** COMMENT Jabber

Sadly, I cannot use =jabber= together with Google or Skype.

#+BEGIN_SRC emacs-lisp
(use-package jabber
  :ensure t
  :defer t
  :config
  (setq jabber-chat-buffer-show-avatar nil
				jabber-vcard-avatars-retrieve nil
				jabber-alert-presence-hooks nil

				;; jabber-account-list ; better configure this in a secret place
				;;     '(("<your-gmail-email>"
				;;        (:network-server . "talk.google.com")
				;;        (:port . 443)
				;;        (:connection-type . ssl))))

))
#+END_SRC

* bbdb

http://sachachua.com/notebook/emacs/bbdb-config.el

#+BEGIN_SRC emacs-lisp
  (use-package bbdb
    :ensure t
    :config (progn
              (bbdb-initialize)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)
                                          ;(add-hook 'gnus-startup-hook 'bbdb-insinuate-message)
                                          ;(add-hook 'message-setup-hook 'bbdb-define-all-aliases)

              (setq bbdb-file "~/Dropbox/bbdb"
                    bbdb-auto-revert t
                    bbdb-check-auto-save-file t
                    bbdb-expand-mail-aliases t
                    bbdb-phone-style nil
                    ;; bbdb-pop-up-window-size 10
                    bbdb-pop-up-target-lines 1 ; The window should be as small as possible
                    bbdb-use-pop-up nil        ; Show pup-up?

                                          ;bbdb/news-auto-create-p t
                    bbdb-complete-name-allow-cycling t
                    bbdb-complete-mail-allow-cycling t
                    bbdb-complete-name-full-completion t
                    bbdb-completion-type 'primary-or-name
                                          ;bbdb-use-pop-up nil

                    bbdb-offer-save 1  ; Always save
                    bbdb-electric-p t)
              ))

  (use-package bbdb-vcard
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-bbdb
    :ensure t)
  (global-set-key (kbd "<f7> a") 'helm-bbdb)
#+END_SRC

* tramp

#+BEGIN_SRC emacs-lisp
  (require 'tramp)
  (if (eq system-type 'windows-nt) 
      (setq tramp-default-method "plink")
    (setq tramp-default-method "ssh"))
  ;; (setq tramp-default-user "")
#+END_SRC

* hydra

Nice examples:
https://github.com/rubensts/.emacs.d#hydra

** hydra: begin

#+BEGIN_SRC emacs-lisp
	(use-package hydra
		:ensure t
		:config

#+END_SRC

** hydra-f1

- [ ] add =finder-commentary=

See also https://www.reddit.com/r/emacs/comments/3ba645/does_anybody_have_any_real_cool_hydras_to_share/cspqaly/

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f1 (:exit t :hint nil)

    "
    ╭────┐      
    │<f1>│  _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
    │Help│  Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭╯    └──^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^────╯

    Describe      ^^Keys                     ^^Elisp           ^^Documentation
    --------------^^-------------------------^^----------------^^---------------
    _m_ode          single _k_eybinding        _a_propros        _i_nfo
    _p_ackage       available _b_indings       _f_unction        _d_ocsets
    _c_ursor        _w_here is key             _v_ariable        _n_: man

  "
    ;; Boring help commands...
    ("e" view-echo-area-messages "messages")
    ("l" view-lossage "lossage")
    ("C" describe-coding-system "coding system")
    ("I" describe-input-method "input method")

    ;; Documentation
    ("i" info nil)
    ("n" helm-man-woman nil)
    ("d" helm-dash nil)

    ;; Keybinds
    ("b" describe-bindings nil)
    ("c" describe-key-briefly nil)
    ("k" describe-key nil)
    ("w" where-is nil)

    ;; Elisp
    ("a" apropos-command nil)
    ("s" info-lookup-symbol nil)
    ("v" describe-variable nil)
    ("f" describe-function nil)
    ("y" describe-syntax nil)

    ;; Describe
    ("p" describe-package nil)
    ("m" describe-mode nil)
		("c" (what-cursor-position t) nil)

		("<f2>" hydra-f2/body :exit t)
		("<f3>" hydra-f3/body :exit t)
		("<f4>" hydra-f4/body :exit t)
		("<f5>" revert-buffer :exit t)
		("<f6>" hydra-f6/body :exit t)
		("<f7>" hydra-f7/body :exit t)
		("<f8>" hydra-f8/body :exit t)
		("<f9>" hydra-f9/body :exit t)
    ;; quit
    ("q" help-quit "quit"))

(global-set-key (kbd "<f1>") #'hydra-f1/body)
#+END_SRC

** hydra-f2

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f2
		(:hint nil
					 :idle 0.2)
	"
         ^^  ╭──────┐       
     _<f1>_  │<f2>  │  _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^  │Window│  Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^──╯      └────────^^────────^^──────────^^───^^───────^^───────^^───────^^────╯

          ^^  _<up>_               │      ^^                    [_z_] window undo
          ^^   ↑   ^^              │split [_h_]orizontally      [_Z_] window redo
    _<left>_ ←   → _<right>_       │      ^^                    [_f_] clone frame
          ^^   ↓   ^^             ────────^^─────────────       [_b_] clone buffer      
          ^^ _<down>_              split [_v_]ertically         [_t_] transpose frame    
                                                                [_q_]uit    
	"
	("<down>" windmove-down :exit t)
	("<up>" windmove-up :exit t)
	("<right>" windmove-right :exit t)
	("<left>" windmove-left :exit t)
	("f" make-frame :exit t)
	("b" clone-indirect-buffer :exit t)
	("v" split-window-vertically :exit t)
	("h" split-window-horizontally :exit t)
	("t" transpose-frame :exit t)
	("z" winner-undo)
	("Z" winner-redo)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f2>") 'hydra-f2/body)
#+END_SRC

** hydra-f3

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f3
		(:hint nil
					 :idle 0.2)
	"

         ^^   ^^         ╭──────┐       
     _<f1>_    _<f2>_    │<f3>  │  _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^    Window^^  │Config│  Check^^   Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^───╯      └───────^^──────────^^───^^───────^^───────^^───────^^────╯
 
         [_i_] init file           [_p_] package manager      [_m_] macros
         [_d_] .emacs.d            [_u_] upgrade packages    
         [_c_] customize emacs     [_t_] load theme           
         [_v_] visual line mode    [_fp_] proportional font    [_q_]uit
	"
	("i" (find-file (expand-file-name org-init-file user-emacs-directory)) :exit t)
	("d" (find-file user-emacs-directory) :exit t)
	("fp" toggle-proportional :exit t)
	("c" customize :exit t)
	("p" paradox-list-packages :exit t)
	("u" paradox-upgrade-packages :exit t)
	("m" hydra-macro/body :exit t)
	("t" hydra-load-theme/body :exit t)
	("v" visual-line-mode :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t))
	(global-set-key (kbd "<f3>") 'hydra-f3/body)
#+END_SRC

** hydra-f4

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f4
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^  ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_    │<f4> │  _<f5>_      _<f6>_   _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^  │Check│  Refresh^^   Mode^^   Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^──╯     └─────────^^───^^───────^^───────^^───────^^─────╯
 
      [_e_] compilation errors      [_c_] code checking     [_s_] spell checking 
      [_#_] count words              ^^                                 [_q_]uit
	"
	("e" hydra-compilation-error/body :exit t)
	("c" hydra-flycheck/body :exit t)
	("s" hydra-flyspell/body :exit t)
	("#" count-words :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f4>") 'hydra-f4/body)
#+END_SRC

** hydra-f6

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f6>") 'hydra-f6/body)

(defun hydra-f6/body () ;hydra-for-major-mode ()
	(interactive)
  (cond
	 ((string-equal (buffer-mode) "deft-mode")
		(hydra-deft/body))
	 ((string-equal (buffer-mode) "dired-mode")
		(hydra-dired-main/body))
	 ((string-equal (buffer-mode) "image-mode")
		(hydra-image/body))
	 ((string-equal (buffer-mode) "latex-mode")
		(hydra-latex-main/body))
	 ((string-equal (buffer-mode) "org-mode")
		(hydra-org-main/body))
	 ((string-equal (buffer-mode) "org-agenda-mode")
		(hydra-org-agenda/body))
	 ((string-equal (buffer-mode) "pomidor-mode")
		(hydra-pomidor/body))
	 ((or t) (message (concat "no hydra defined for major mode"))))
)
#+END_SRC

Function to look up the major mode of a buffer:
#+BEGIN_SRC emacs-lisp
(defun buffer-mode (&optional buffer-or-name)
  "Returns the major mode associated with a buffer.
If buffer-or-name is nil return current buffer's mode."
  (buffer-local-value 'major-mode
											(if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+END_SRC

Deprecated:

#+BEGIN_SRC 
(defvar hydra-f6-menu
	"
         ^^         ^^         ^^       ^^        ^^     ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_     │<f6>│  _<f7>_   _<f8>_   _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^  │Mode│  Open^^   Mark^^   Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^──╯    └────^^─────────^^──────^^─╯
 
    ^^ _<f6>_: hydra for major mode ^^ ^^ ^^ ^^ ^^ ^^                         [_q_]uit
	"
)

	(defhydra hydra-f6-old
		(:hint nil
					 :idle 0.2)
(concat hydra-f6-menu) 
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-for-major-mode :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)
)
#+END_SRC

** hydra-f7

#+BEGIN_SRC emacs-lisp
(defhydra hydra-f7
	(:hint nil
				 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_  │<f7>│  _<f8>_  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^  │Open│  Mark^^  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^──╯    └──────^^────────╯
 
       [_a_] adress book        [_d_] dired/file browser     [_t_] pomodoro timer
       [_b_] new buffer         [_e_] emacs shell            [_l_] dictionary
       [_i_] buffer overview    [_s_] system shell           [_B_] bookmarks
       [_c_] calendar           [_m_] magit status           [_P_] pandoc
       [_p_] projectile          ^^                           ^^                [_q_]uit
	" 
	("a" helm-bbdb :exit t)
	("c" my-open-calfw :exit t)
	("d" dired-jump :exit t)
	("s" shell :exit t)
	("b" xah-new-empty-buffer :exit t)
	("i" ibuffer :exit t)
	("l" dictcc :exit t)
	("m" magit-status :exit t)
	("e" tl/eshell :exit t)
	("B" bookmark-bmenu-list :exit t)
	("p" helm-projectile :exit t)
	("P" pandoc-main-hydra/body :exit t)
	("t" pomidor :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f8>" hydra-f8/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
(global-set-key (kbd "<f7>") 'hydra-f7/body)
#+END_SRC

** hydra-f8

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f8
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^      ╭─────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_  │<f8> │  _<f9>_ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^  │Mark │  Org^^
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^──╯     └─────^^─╯

      [_a_] mark all
      [_c_] highlight changes        [_w_] show/hide whitespaces   [_b_] add bookmark
      [_g_] git gutter               [_*_] critic markup           [_t_] tags
      [_s_] highlight same symbols   [_r_] mark rectangular               [_q_]uit
	"
	("a" mark-whole-buffer :exit t)
	("g" hydra-git-gutter/body :exit t)
	("c" hydra-highlight-changes/body :exit t)
	("r" rectangle-mark-mode :exit t)
	("b" bookmark-set :exit t) 
	("s" hydra-highlight-symbol/body :exit t)
	("t" hydra-tags/body :exit t)
	("w" whitespace-mode :exit t)
  ("*" hydra-cm-mode/body :exit t )
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f9>" hydra-f9/body :exit t)

)
	(global-set-key (kbd "<f8>") 'hydra-f8/body)
#+END_SRC

** hydra-f9

Global org-mode keys:

#+BEGIN_SRC emacs-lisp
	(defhydra hydra-f9
		(:hint nil
					 :idle 0.2)
	"
         ^^         ^^         ^^       ^^        ^^      ^^       ^^       ^^      ╭────┐       
     _<f1>_   _<f2>_     _<f3>_     _<f4>_    _<f5>_      _<f6>_   _<f7>_   _<f8>_  │<f9>│ 
     Help^^   Window^^   Config^^   Check^^   Refresh^^   Mode^^   Open^^   Mark^^  │Org │
   ╭─────^^─────────^^─────────^^────────^^──────────^^───────^^───────^^───────^^──╯    ╵
 
     ^^  [_a_] agenda  ^^    [_n_] notes   ^^  ^^   ^^  ^^  ^^   [_r_] reload org       	
     ^^  [_d_] deft    ^^    [_t_] todos   ^^  ^^   ^^  ^^  ^^   [_u_] update agenda files
     ^^  [_c_] capture ^^    [_w_] work ^^  ^^  ^^  ^^ ^^        
     ^^  [_f_] search  ^^    [_:_] tags ^^  ^^  ^^  ^^  ^^                      [_q_]uit

	"
	("a" org-agenda-list-work :exit t)
	("d" deft :exit t)
	("n" (lambda nil (interactive)
				 (find-file (concat org-directory "/notes.org"))) :exit t)
	("o" deft :exit t)
	("c" org-capture :exit t)
	("t" org-todo-list :exit t)
	("w" (lambda nil (interactive)
				 (find-file (concat org-directory "/work/work.org"))) :exit t)
	(":" org-setting-tags :exit t)
	("r" org-reload :exit t)
	("f" helm-org-rifle-agenda-files :exit t)
	;; ("f" org-search-view :exit t)
	("s" org-search-view :exit t)
	("u" tl/update-org-agenda-files :exit t)
	("q" nil :color blue)
	("<f1>" hydra-f1/body :exit t)
	("<f2>" hydra-f2/body :exit t)
	("<f3>" hydra-f3/body :exit t)
	("<f4>" hydra-f4/body :exit t)
	("<f5>" revert-buffer :exit t)
	("<f6>" hydra-f6/body :exit t)
	("<f7>" hydra-f7/body :exit t)
	("<f8>" hydra-f8/body :exit t)

)
	(global-set-key (kbd "<f9>") 'hydra-f9/body)

#+END_SRC

** hydra-cm-mode

#+BEGIN_SRC emacs-lisp
(defhydra hydra-cm-mode
	(:body-pre (when (not (string-equal cm-mode "t"))
							 (font-lock-mode -1)
							 (font-lock-mode 1)
							 (cm-mode 1))
						 :hint nil)
			"
     CriticMarkup
   ╭──────────────╯
      [_<up>_] previous      [_a_] addition         [_i_] accept/reject
    [_<down>_] next          [_d_] deletion         [_I_] accept/reject all
     ^^                      [_s_] substitution
     [_F_] follow changes    [_c_] comment          [_q_]uit													
		 ^^											 ^^							  			[_Q_]uit and deactivate cm-mode
"
			("<up>" #'cm-backward-change)
			("<down>" #'cm-forward-change)
			("a" #'cm-addition :color blue)
			("d" #'cm-deletion :color blue)
			("s" #'cm-substitution :color blue)
			("c"#'cm-comment :color blue)
			("i" #'cm-accept/reject-change-at-point)
			("I" #'cm-accept/reject-all-changes)
			("t" #'cm-set-author)
			("F" #'cm-follow-changes :color blue)
			("q" nil :color blue)
			("Q" (cm-mode -1) :color blue))
(global-set-key (kbd "C-*") 'hydra-cm-mode/body)
#+END_SRC

** hydra-dired

https://gitlab.com/xuhdev/dired-quick-sort

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dired-main (:hint nil)
"
 ^Navigation^            ^^            ^Mark^              ^Actions^             ^View^
-^----------^------------^^------------^----^--------------^-------^-------------^----^------------

             _<up>_      ^^             _m_: mark           _+_: new						  _g_: refresh              
  ^^            ʌ        ^^             _u_: unmark         _C_: copy to          _/_: filter 
  ^^                     ^^             _U_: unmark all     _D_: delete           _s_: sort		 
  _<left>_  ..     view  _<right>_      _t_: toggle mark    _R_: move to          _(_: details
  ^^               enter _RET_          _*_: specific       _r_: rename           _z_: size
  ^^                     ^^             ^^                  ^^
  ^^            v        ^^             _w_: copy file name _P_: change property
            _<down>_     ^^             _W_: copy path      _c_/_Z_: compress				  
  ^^                     ^^             ^^                  _=_: diff             _q_: quit dired     
   _._: home  _j_: jump  _f_: find                          _e_: diff on marked   _Q_: quit hydra
                                                    
-^----------^------------------------^----^---------------^-------^-------------^----^-----------
"

("<left>" (lambda () (interactive) (find-alternate-file "..")))
("<up>" diredp-previous-line)
("<down>" diredp-next-line)
("RET" dired-find-file)
("<right>" dired-view-file)
("+" hydra-dired-new/body :color blue)
("*" hydra-dired-mark/body :color blue)
("P" hydra-dired-properties/body :color blue)
("O" dired-do-chown)
("M" dired-do-chmod)
("G" dired-do-chgrp)
("C" dired-do-copy)
("D" dired-do-delete)
("<delete>" dired-do-delete)
("R" dired-do-rename)
("S" dired-do-symlink)
("Z" dired-do-compress)
("c" dired-do-compress-to)
("/" dired-narrow)
("(" dired-hide-details-mode)
("f" my-find-name-dired)
("." (find-file home-directory))
;; ("=" diredp-ediff)  ; FIXME: does not work under windows; does not find diff 
("=" dired-diff)
("e" ora-ediff-files)
("g" revert-buffer)
("j" dired-goto-file)
("r" dired-efap)
("s" dired-sort-toggle-or-edit)
("m" dired-mark)
("u" dired-unmark)
("U" dired-unmark-all-marks)
("t" dired-toggle-marks)
("v" dired-view-file)
("w" dired-copy-filename-as-kill)
("W" tl/dired-copy-path-at-point)
("z" dired-get-size)
("q" quit-window :color blue)
("Q" nil :color blue)
)

(defhydra hydra-dired-new (:hint nil )
	"New"
	("d" dired-create-directory "directory"  :exit t :after-exit (hydra-dired-main/body))
	("f" find-file "file" :exit t)
	("s" dired-do-symlink "symbolic link" :exit t :after-exit (hydra-dired-main/body))
	("h" dired-do-hardlink "hard link" :exit t :after-exit (hydra-dired-main/body))
	("q" hydra-dired-main/body "quit" :color blue)
	)

(defhydra hydra-dired-mark (:hint nil :after-exit (hydra-dired-main/body))
"Mark"
	("a" (dired-mark-files-regexp ".*") "all" :exit t)
	("d" dired-mark-directories "directories" :exit t)
	("." diredp-mark/unmark-extension "by extension" :exit t)
	("s" dired-mark-symlinks "symbolic links" :exit t)
	("r" dired-mark-files-regexp "by regexp" :exit t)
	("/" dired-mark-sexp "by search term" :exit t)
	("q" hydra-dired-main/body "quit" :exit t)
	)

(defhydra hydra-dired-properties (:hint nil :after-exit (hydra-dired-main/body))
"Change"
	("o" dired-do-chown "owner")
	("r" dired-do-chmod "rights")
	("g" dired-do-chgrp "group")
	("q" hydra-dired-main/body "quit" :color blue)
	)
#+END_SRC

Don't ask for the path when searching for files:
#+BEGIN_SRC emacs-lisp
(defun my-find-name-dired (pattern)
  "My version of find-name-dired that always starts in my chosen folder"
  (interactive "sFind Name (file name wildcard): ")
  (dired-hide-details-mode)
  (find-name-dired "." pattern))
#+END_SRC

** hydra-org

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-main (:hint nil)
	"Org-mode"
	("a" org-attach "attachments..." :exit t)
	("A" hydra-org-archive/body "archive..." :exit t)
	("b" org-tree-to-indirect-buffer "open in new buffer" :exit t)
	("c" hydra-org-columns/body "columns..." :exit t)
	("n" org-add-note "add note" :exit t)
	("p" org-set-property "add property" :exit t)
	("P" org-set-property-and-value "add property-value pair" :exit t)
	("r" org-ref "org-ref" :exit t)
	("s" org-sort "sort" :exit t)
	("$" org-latex-fragment-toggle-toggle "show LaTeX" :exit t)
	("t" org-todo "todo" :exit t)
	(":" org-set-tags "tags" :exit t)
	("+" org-priority-up "priority up" :exit nil)
	("-" org-priority-down "priority down" :exit nil)
	("\\" org-toggle-pretty-entities "toggle utf8 chars" :exit t)
	("^" org-sort nil :exit t)
	("q" nil :color blue)
	)
#+END_SRC

*** hydra-org-archive

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-archive (:hint nil)
	"Org-mode archive"
	("t" org-toggle-archive-tag "set archive tag" :exit t)
	("a" org-archive-to-archive-sibling "archive below" :exit t)
	("A" org-archive-subtree-default "archive outside" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

*** hydra-org-columns

A hydra for org-columns.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-columns (:hint nil :color pink :body-pre (org-columns))
"Org-mode columns"
(">" org-columns-widen "widen")
("<" org-columns-narrow "narrow")
("a" org-columns-edit-allowed "allowed values" :exit t)
("c" org-columns-content "content" :exit t)
("e" org-columns-edit-value "edit" :exit t)
("n" org-columns-next-allowed-value "next allowed value")
("p" org-columns-previous-allowed-value "previous allowed value")
("r" org-columns-redo "refresh")
("s" org-columns-edit-attributes "select attribute")
("t" org-columns-todo "todo")
("M-S-<left>" org-columns-delete "delete")
("M-S-<right>" org-columns-new "new")
("M-<right>" org-columns-move-right "move right")
("M-<left>" org-columns-move-left "move left")
("<delete>" org-columns-delete)
("v" org-columns-show-value "show value")
("q" org-columns-quit :color blue)
)
#+END_SRC

*** hydra-org-agenda

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-agenda (:hint nil :color pink)
	"Org-agenda view"
	("+" org-agenda-priority-up "priority up" :exit nil)
	("-" org-agenda-priority-down "priority down" :exit nil)
	("d" org-agenda-day-view "day view" :exit nil)
	("h" org-agenda-holidays "holidays" :exit nil)
	("j" org-agenda-goto-date "jump to date" :exit nil)
	("k" org-agenda-kill "kill" :exit nil)
	("t" org-agenda-todo "todo keyword" :exit nil)
	("/" org-agenda-filter-by-tag "filter by tag" :exit nil)
	(":" org-agenda-set-tags "set tags" :exit nil)
	("r" org-agenda-redo "refresh" :exit nil)
	("q" nil :color blue)
	)
#+END_SRC

** hydra-deft

#+BEGIN_SRC emacs-lisp
(defhydra hydra-deft (:hint nil)
"Deft"
("a" deft-archive-file "archive" :exit t)
("d" deft-delete-file "delete" :exit t)
("k" deft-delete-file nil :exit t)
("f" deft-find-file "find" :exit t)
("g" deft-refresh "refresh" :exit t)
("n" deft-new-file "new" :exit t)
("r" deft-rename-file "rename" :exit t)
("l" deft-filter "filter" :exit t)
("/" deft-filter nil :exit t)
("Q" quit-window "quit" :exit t)
("q" nil :color blue)
)
#+END_SRC

** hydra-git-gutter

#+BEGIN_SRC emacs-lisp

		;; inspired by https://github.com/abo-abo/hydra/wiki/Git-gutter
		(defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
																					:hint nil)
			"
     Git gutter
   ╭────────────╯
    [_j_] next hunk        [_s_]tage hunk     [_q_]uit
    [_k_] previous hunk    [_r_]evert hunk    [_Q_]uit and deactivate git-gutter
     ^ ^                   [_p_]opup hunk
    [_h_] first hunk
    [_l_] last hunk        set start [_R_]evision
	"
			("j" git-gutter:next-hunk)
			("k" git-gutter:previous-hunk)
			("h" (progn (goto-char (point-min))
									(git-gutter:next-hunk 1)))
			("l" (progn (goto-char (point-min))
									(git-gutter:previous-hunk 1)))
			("s" git-gutter:stage-hunk)
			("r" git-gutter:revert-hunk)
			("p" git-gutter:popup-hunk)
			("R" git-gutter:set-start-revision)
			("q" nil :color blue)
			("Q" (progn (git-gutter-mode -1)
									;; git-gutter-fringe doesn't seem to
									;; clear the markup right away
									(sit-for 0.1)
									(git-gutter:clear))
			 :color blue))
#+END_SRC

** hydra-ibuffer

Adapted hydra from https://github.com/abo-abo/hydra/wiki/Ibuffer:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^      ^Mark^          ^Actions^          ^View^
-^----------^------^----^----------^-------^----------^----^-------
   _<up>_:   ʌ     _m_: mark       _D_: delete        _g_: refresh
    _RET_: visit   _u_: unmark     _S_: save          _s_: sort
 _<down>_:   v     _*_: specific   _a_: all actions   _/_: filter
-^----------^---^----^----------^-------^----------^----^----------
"
  ("j" ibuffer-forward-line)
  ("<down>" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("<up>" ibuffer-backward-line)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" ibuffer-quit "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))
#+END_SRC

Automatically open the hydra with ibuffer:

#+BEGIN_SRC emacs-lisp
(add-hook 'ibuffer-hook #'hydra-ibuffer-main/body)
#+END_SRC

** hydra-image

#+BEGIN_SRC emacs-lisp
(defhydra hydra-image ()
	"Manipulate image"
	("+" imagex-sticky-zoom-in "zoom in")
	("-" imagex-sticky-zoom-out "zoom out")
	("m" imagex-sticky-maximize "maximize")
	("o" imagex-sticky-restore-original "original")
	;; ("S" imagex-sticky-save-image "save")
	("r" imagex-sticky-rotate-right "rotate right")
	("l" imagex-sticky-rotate-left "rotate left"))

#+END_SRC

** hydra-latex

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-main (:hint nil)
	"LaTeX"
	("<up>" tl/reftex-previous "previous heading" :exit nil)
	("<down>" tl/reftex-next "next heading" :exit nil)
	("p" tl/reftex-previous :exit nil)
	("n" tl/reftex-next :exit nil)
	("=" reftex-toc "table of contents" :exit t)
	("d" hydra-latex-delete/body "delete..." :exit t)
	("f" hydra-latex-fonts/body "font..." :exit t)
	("c" TeX-command-master "compile" :exit t)
	("l" TeX-recenter-output-buffer "show log" :exit t)
	("s" isearch-forward "search" :exit t)
	("o" hydra-latex-folding/body "folding..." :exit t)
	("v" TeX-view "view output" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for code folding with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-folding (:hint nil :body-pre (TeX-fold-mode 1))
	"LaTeX folding"
	("b" TeX-clearout-buffer "remove folding in buffer" :exit t)
	("B" TeX-fold-buffer "activate folding in buffer" :exit t)
	("o" TeX-fold-dwim "fold dwim" :exit t)
	("Q" TeX-fold-mode "quit TeX-fold-mode" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for code deletion with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-delete (:hint nil)
	"LaTeX deletion"
	("f" TeX-deletefont "font" :exit t)
	("e" TeX-delete-environment "environment" :exit t)
	("m" TeX-delete-macro "macro" :exit t)
	("t" TeX-clean "temporary files" :exit t)
	("q" nil :color blue)
	)
#+END_SRC

A hydra for font selection with AUCTeX:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-latex-fonts (:hint nil)
	"LaTeX fonts"
	("b" TeX-bold "bold" :exit t)
	("i" TeX-italic "italic" :exit t)
	("t" TeX-typewriter "typewriter" :exit t)
	("s" TeX-smallcaps "smallcaps" :exit t)
	("e" TeX-emphasis "emphasis" :exit t)
	("d" TeX-deletefont "delete" :exit t)
	("!b" TeX-bold-replace "replace with bold" :exit t)
	("!i" TeX-italic-replace "replace with italic" :exit t)
	("!t" TeX-typewriter-replace "replace with typewriter" :exit t)
	("!s" TeX-smallcaps-replace "replace with smallcaps" :exit t)
	("!e" TeX-emphasis-replace "replace with emphasis" :exit t)
	("q" nil :color blue)
	)
#+END_SRC
 
** hydra-flycheck

#+BEGIN_SRC emacs-lisp
		;; inspired by https://github.com/abo-abo/hydra/wiki/Flycheck
		(defhydra hydra-flycheck
			(:pre (progn (setq hydra-lv t) (flycheck-mode +1) (flycheck-list-errors))
						:post (progn (setq hydra-lv nil) (quit-windows-on "*Flycheck errors*"))
						:hint nil)
"
  Errors
╭────────╯
"
			("f"  flycheck-error-list-set-filter                            "Filter")
			("j"  flycheck-next-error                                       nil)
			("<down>"  flycheck-next-error                                       "Next")
			("k"  flycheck-previous-error                                   nil)
			("<up>"  flycheck-previous-error                                   "Previous")
			("[" flycheck-first-error                                      "First")
			("]"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
			("Q"  (flycheck-mode -1) "Quit flycheck-mode") 
			("q"  nil))
#+END_SRC

** hydra-flyspell

#+BEGIN_SRC emacs-lisp
(defhydra hydra-flyspell (:pre (flyspell-mode +1)
															 :color blue
															 :hint nil
															 :idle 0.2)
    "
   ^^                            ^^                             ╭──────────┐
   ^^Flyspell                    ^^Ispell                       │ Flyspell │
╭──^^────────────────────────────^^─────────────────────────────┴──────────╯
    [_<up>_] previous error       [_b_] check buffer
       [_c_] correct word         [_w_] check word           
  [_<down>_] next error           [_d_] change dictionary   
       [_f_] toggle flyspell                             [_q_] quit window 
       [_p_] toggle prog mode                            [_Q_] quit flyspell
      "
    ("w" ispell-word :color red)
    ("i" ispell)
		("b" ispell-buffer)
    ("d" ispell-change-dictionary)
    ("f" flyspell-mode)
    ("p" flyspell-prog-mode)
    ("c" flyspell-auto-correct-word)
    ("<up>"  flyspell-previous-and-ispell-word :color red)
		("<down>" flyspell-next-and-ispell-word :color red)
    ("k"  flyspell-previous-and-ispell-word :color red)
		("j" flyspell-next-and-ispell-word :color red)
    ("q" nil)
    ("Q" (flyspell-mode -1)))

#+END_SRC

** hydra-compilation-error

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/Compilation
(defhydra hydra-compilation-error (:hint nil :body-pre (hydra-compilation-error-body-pre))
	"
	    Compilation errors
    ╭────────────────────╯
	      [_<up>_] previous error   [_l_] list errors    [_q_]uit
	    [_<down>_] next error       
	"
	("`" hydra-compilation-error-next)
	("j" hydra-compilation-error-next)
	("<down>" hydra-compilation-error-next)
	("k" hydra-compilation-error-previous)
	("<up>" hydra-compilation-error-previous)
	("l" hydra-compilation-error-list :exit t)
	("o" hydra-compilation-error-list :exit t)
	("q" hydra-compilation-error-quit nil :color blue))

(defun hydra-compilation-error-next ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))

(defun hydra-compilation-error-previous ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-previous-error 1)))

(defun hydra-compilation-error-list ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-error-overview)))

(defun hydra-compilation-error-quit ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(delete-other-windows)))

(defun hydra-compilation-error-body-pre ()
	(interactive)
  (when (string-equal (buffer-mode) "latex-mode")
		(TeX-next-error 1)))
#+END_SRC

** hydra-multiple-cursors

#+BEGIN_SRC emacs-lisp
;; inspired by https://github.com/abo-abo/hydra/wiki/multiple-cursors
(defhydra hydra-multiple-cursors (:hint nil :idle 0.2)
	"
    			 ^Up^                   ^Down^            ^Other^
   ╭───^^─────────────────────────^^────────────^^───────────────────╯
    [_S-<up>_] Next      [_S-<down>_] Next       [_l_] Edit lines
      [_<up>_] Skip        [_<down>_] Skip       [_a_] Mark all
    [_M-<up>_] Unmark    [_M-<down>_] Unmark     [_r_] Mark by regexp
    ^ ^                     [_q_] Quit hydra     [_Q_] Quit mc-mode
	"
	("l" mc/edit-lines :exit t)
	("a" mc/mark-all-like-this :exit t)
	("n" mc/mark-next-like-this)
	("N" mc/skip-to-next-like-this)
	("M-n" mc/unmark-next-like-this)
	("S-<down>" mc/mark-next-like-this)
	("<down>" mc/skip-to-next-like-this)
	("M-<down>" mc/unmark-next-like-this)
	("p" mc/mark-previous-like-this)
	("P" mc/skip-to-previous-like-this)
	("M-p" mc/unmark-previous-like-this)
	("S-<up>" mc/mark-previous-like-this)
	("<up>" mc/skip-to-previous-like-this)
	("M-<up>" mc/unmark-previous-like-this)
	("S-<down-mouse-1>" mc/add-cursor-on-click)
	("r" mc/mark-all-in-region-regexp :exit t)
  ("Q" (multiple-cursors-mode -1) :exit t)
	("q" nil))
(global-set-key (kbd "C-<") 'hydra-multiple-cursors/body)
(global-set-key (kbd "M-+") 'hydra-multiple-cursors/body)
  #+END_SRC

** hydra-highlight-changes

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-changes
			(:body-pre (highlight-changes-visible-mode +1)
      :hint nil
      :idle 0.5)
			"
    Highlight changes
  ╭───────────────────╯
	  _<up>_: next change       _q_uit
  _<down>_: previous change   _Q_uit and turn off highlighting 
	"
			("<down>" highlight-changes-next-change)
			("<up>" highlight-changes-previous-change)
			("<right>" highlight-changes-next-change)
			("<left>" highlight-changes-previous-change)
			("j" highlight-changes-next-change)
			("k" highlight-changes-previous-change)
			("n" highlight-changes-next-change)
			("p" highlight-changes-previous-change)
			("Q" (highlight-changes-visible-mode -1) :color blue)
			("q" nil :color blue))
#+END_SRC

** hydra-highlight-symbol

#+BEGIN_SRC emacs-lisp
		(defhydra hydra-highlight-symbol
			(:pre (highlight-symbol-at-point) 
      :hint nil
			 :idle 0.5)
			"
   Highlight symbol
 ╭──────────────────╯
    _<up>_: previous occurrence    _r_: replace occurrences     _q_uit 
  _<down>_: next occurrence        
	"
			("<down>" highlight-symbol-next)
			("<up>" highlight-symbol-prev)
			("<right>" highlight-symbol-next)
			("<left>" highlight-symbol-prev)
			("j" highlight-symbol-next)
			("k" highlight-symbol-prev)
			("n" highlight-symbol-next)
			("p" highlight-symbol-prev)
			("c" highlight-symbol-count)
			("r" highlight-symbol-query-replace)
			("l" highlight-symbol-list-all)
			("q" highlight-symbol-remove-all :color blue))
#+END_SRC

** hydra-pomidor

#+BEGIN_SRC emacs-lisp
(defhydra hydra-pomidor (:color blue)
	"Pomidor"
	("<return>" pomidor-stop "next")
	("<space>" pomidor-break "pause")
	("R" pomidor-reset "reset")
	("q" quit-window "quit window")
	("Q" pomidor-quit "quit pomidor")
)
#+END_SRC

** hydra-load-theme

Switch between installed themes.

Copied from http://www.superloopy.io/articles/2017/hydra-theme-switcher.html:

#+BEGIN_SRC emacs-lisp
(defun sb/disable-all-themes ()
  (interactive)
  (mapc #'disable-theme custom-enabled-themes))

(defun sb/load-theme (theme)
  "Enhance `load-theme' by first disabling enabled themes."
  (sb/disable-all-themes)
  (load-theme theme))

(setq sb/hydra-selectors
      "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

(defun sb/sort-themes (themes)
  (sort themes (lambda (a b) (string< (symbol-name a) (symbol-name b)))))

(defun sb/hydra-load-theme-heads (themes)
  (mapcar* (lambda (a b)
             (list (char-to-string a) `(sb/load-theme ',b) (symbol-name b)))
           sb/hydra-selectors themes))

(bind-keys ("C-c w t" .
            (lambda ()
              (interactive)
              (call-interactively
               (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
                        "Select Theme"
                        ,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
                        ("DEL" (sb/disable-all-themes))
                        ("RET" nil "done" :color blue)))))))
#+END_SRC

I've added this to make it fit into [[*hydra-f3][hydra-f3]]:

#+BEGIN_SRC emacs-lisp
(defun hydra-load-theme/body ()
	(interactive)
	(call-interactively
	 (eval `(defhydra sb/hydra-select-themes (:hint nil :color pink)
						"Select Theme"
						,@(sb/hydra-load-theme-heads (sb/sort-themes (custom-available-themes)))
						("DEL" (sb/disable-all-themes))
						("q" nil "quit" :color blue))))
)
#+END_SRC

** hydra-tags

#+BEGIN_SRC emacs-lisp
(defhydra hydra-tags (:color red)
	"Tags"
	("." helm-etags-select "goto definition" :color blue)
	("q" nil "cancel" :color blue))
#+END_SRC

** hydra-transpose

Taken from https://github.com/abo-abo/hydra/wiki/Emacs

#+BEGIN_SRC emacs-lisp
(defhydra hydra-transpose (:color red)
	"Transpose"
	("c" transpose-chars "characters")
	("w" transpose-words "words")
	("x" transpose-sexps "expressions")
	("l" transpose-lines "lines")
	("s" transpose-sentences "sentences")
	("p" transpose-paragraphs "paragraphs")
	("f" transpose-frame "frame")
	("o" org-transpose-words "Org-words")
	("e" org-transpose-element "Org-elements")
	("tp" org-table-transpose-table-at-point "Org-table at point")
	("tc" hydra-org-table-move-cell/body "Org-table cell")
	("C-t" nil nil :color blue)
	("q" nil "cancel" :color blue))
(global-set-key (kbd "C-t") 'hydra-transpose/body)
#+END_SRC

** hydra-org-table-move-cell

Uses [[*Tables][org-table-move-single-cell]]:

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-table-move-cell (:hint nil
																					 :idle 0.5)
	"
   Move org-table cell
 ╭─────────────────────╯
    _<up>_: move up       _<left>_: move left    
  _<down>_: move down    _<right>_: move left     _q_uit
	"
	("<up>" org-table-move-single-cell-up)
	("<down>" org-table-move-single-cell-down)
	("<right>" org-table-move-single-cell-right)
	("<left>" org-table-move-single-cell-left)
	("q" nil :color blue))
#+END_SRC

** TODO hydra-macro

Inspired by: https://github.com/abo-abo/hydra/wiki/Macro
#+BEGIN_SRC emacs-lisp
(defhydra hydra-macro (:hint nil :color pink :pre 
                             (when defining-kbd-macro
															 (kmacro-end-macro 1)))
  "
  ^Create-Cycle^   ^Basic^           ^Insert^        ^Save^         ^Edit^
╭─────────────────────────────────────────────────────────────────────────╯
     ^_i_^           [_e_] execute    [_n_] insert    [_b_] name      [_'_] previous
     ^^↑^^           [_d_] delete     [_t_] set       [_K_] key       [_,_] last
 _j_ ←   → _l_       [_o_] edit       [_a_] add       [_x_] register     
     ^^↓^^           [_r_] region     [_f_] format    [_B_] defun
     ^_k_^           [_m_] step
    ^^   ^^          [_s_] swap
"
  ("j" kmacro-start-macro :color blue)
  ("l" kmacro-end-or-call-macro-repeat)
  ("i" kmacro-cycle-ring-previous)
  ("k" kmacro-cycle-ring-next)
  ("r" apply-macro-to-region-lines)
  ("d" kmacro-delete-ring-head)
  ("e" kmacro-end-or-call-macro-repeat)
  ("o" kmacro-edit-macro-repeat)
  ("m" kmacro-step-edit-macro)
  ("s" kmacro-swap-ring)
  ("n" kmacro-insert-counter)
  ("t" kmacro-set-counter)
  ("a" kmacro-add-counter)
  ("f" kmacro-set-format)
  ("b" kmacro-name-last-macro)
  ("K" kmacro-bind-to-key)
  ("B" insert-kbd-macro)
  ("x" kmacro-to-register)
  ("'" kmacro-edit-macro)
  ("," edit-kbd-macro)
  ("q" nil :color blue))
#+END_SRC

** hydra: end
  #+BEGIN_SRC emacs-lisp
		)                   
#+END_SRC
